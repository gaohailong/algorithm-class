## 课堂作业一

### Problem A. 课堂作业-9-1
```
时间限制 1000 ms
内存限制 64 MB
题目描述
楼梯有n阶，可以一步上一阶、两阶或三阶，问有多少种不同的走法
由于答案很大，mod(1e9+7)输出

输入数据
一个正整数n，代表楼梯的阶数，n<=1000000

输出数据
方案数

样例输入
3
样例输出
4
```


代码：
```

```
### Problem B. 全排列

```
时间限制 1000 ms
内存限制 128 MB
题目描述
输入两个自然数m,n 1< =n< =20，1< =m< =n!
输出n个数的第m种全排列。
如 ：
输入 3 1
输出 1 2 3

输入数据
在一行中输入 n m
输出数据
一个数列,既 n 个数的第 m 种排列
每两个数之间空 1 格
样例输入
3 2
样例输出
1 3 2
```


代码：
```
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

int main() {
	 int n;
	 long m;
	 cin >> n;
	 cin >> m;
	
	 long long *array = new long long[n + 1];
	 long long sum = 1;
	 array[0] = 1;
	
	 
	 for (int i = 1; i <= n; i++) {
		  sum *= i;
		  array[i] = sum;
	 } 
	 int a[20] = {0};
	 for (int i = 0; i < n; i++) {
	 	 a[i]=i + 1;
	 }
	 vector<int> nums(a, a + n);
	 
	 vector<int>nums2;
	 nums2.reserve(1000);
	 m--;
	 for (int i = 1; i <= n; i++) {
		  int index = m / array[n - i];
		  nums2.push_back(nums[index]);
		  auto it = remove(nums.begin(), nums.end(), nums[index]);
		  nums.erase(it, nums.end());
		  m = m % array[n - i];
	 }
	 auto it = nums2.begin();
	 for (int i = 0; i < n; i++)
	 {
		  cout << *it << " ";
		  it++;
	 }
	 cout << endl;
	 return 0;
}
```

## 研究生算法第一次课下作业
Problem A. 数的计数
```
时间限制 1000 ms
内存限制 128 MB
题目描述
　　我们要求找出具有下列性质数的个数(包含输入的自然数n):
　　先输入一个自然数n(n≤1000)，然后对此自然数按照如下方法进行处理
　　 l·不作任何处理:
　　2·茬它的左边加上一个自然数，但该自然数不能超过原数的一半;
　　3·加上数后，继续按此规则进行处理，直到不能再立生自然数为止。

输入数据
输出数据
样例输入
6
样例输出
6
```
代码：
```
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1005;
 
int n,f[maxn]={1},ans;
 
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		for(int j=0;j<=i/2;j++)
			f[i] += f[j];
	cout<<f[n]<<endl;
	return 0;
}
```
### Problem B. 均分纸牌
```
时间限制 1000 ms
内存限制 128 MB
题目描述
有 N 堆纸牌，编号分别为 1，2，…, N。每堆上有若干张，但纸牌总数必为 N 的倍数。可以在任一堆上取若于张纸牌，然后移动。
　　移牌规则为：在编号为 1 堆上取的纸牌，只能移到编号为 2 的堆上；在编号为 N 的堆上取的纸牌，只能移到编号为 N-1 的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。
　　现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。

　　例如 N=4，4 堆纸牌数分别为：
　　①　9　②　8　③　17　④　6
　　移动3次可达到目的：
　　从 ③ 取 4 张牌放到 ④ （9 8 13 10） -> 从 ③ 取 3 张牌放到 ②（9 11 10 10）-> 从 ② 取 1 张牌放到①（10 10 10 10）。

输入数据
N （ N  堆纸牌， 1 ≤ N ≤ 100 ）
A1 A2 … An （ N  堆纸牌，每堆纸牌初始数， l≤ Ai < 104 ）
输出数据
所有堆均达到相等时的最少移动次数。
样例输入
4
9 8 17 6
样例输出
3
```
代码：
```

#include <stdio.h>
int n;//纸牌堆数
int poke[100];
int count=0;
 
void move(int aver,int k)//移动纸牌，思路就是将每一堆排都变成均值排数
{
	int a;
	a=aver - poke[k];
	poke[k] += a;
	poke[k+1] -= a;
	count++;
	while(poke[k] == aver)
	k++;
	if(k < n)
	move(aver,k);
}
int main()
{
	int i,k;
	int aver;
	scanf("%d",&n);
	for(i=0;i < n;i++)
	{
		scanf("%d",&poke[i]);
		aver+=poke[i];
	}
	aver=aver/n;
	k=n;
	for(i=0;i < n;i++)
	{
		if(poke[i] != aver)
		{
			k=i;
			break;
		}
	}
	if(k < n)
	move(aver,k);
	printf("%d",count);
	return 0;
} 
```

### Problem C. Superprime
```
时间限制 1000 ms
内存限制 128 MB
题目描述
农民约翰的母牛总是生产出最好的肋骨。你能通过农民约翰和美国农业部标记在每根肋骨上的数字认出它们。
农民约翰确定他卖给买方的是真正的质数肋骨,是因为从右边开始切下肋骨,每次还剩下的肋骨上的数字都组成一个质数,举例来说:
7 3 3 1
全部肋骨上的数字 7331是质数;三根肋骨 733是质数;二根肋骨 73 是质数;当然,最后一根肋骨 7 也是质数。

7331 被叫做长度 4 的特殊质数。
写一个程序对给定的肋骨的数目 N (1< =N< =8),求出所有的特殊质数。数字1不被看作一个质数。

输入数据
单独的一行包含 N 。
输出数据
按顺序输出长度为  N  的特殊质数,每行一个。
并按大小顺序排列(从小到大).
样例输入
4
样例输出
2333
2339
2393
2399
2939
3119
3137
3733
3739
3793
3797
5939
7193
7331
7333
7393
```
代码：
```

#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <queue>
#include <vector>
using namespace std;
typedef long long ll;
vector<ll>  v[10];
#define MAX 1e9+7
ll yang(ll m)
{
    ll i;
    ll k;
    k=sqrt(m);
    for(i=2; i<=k; i++)
        if(m%i==0)
            break;
    if(i==k+1)
        return 1;
    else
        return 0;
}
int main()
{
    ll i,k,t,n,m=0,j,ans[10101]={0};
    cin>>n;
    v[1].push_back(2);
    v[1].push_back(3);
    v[1].push_back(5);
    v[1].push_back(7);
    for(k=1;k<=7;k++)
    {
        for(i=0;i<v[k].size();i++)
        {
            for(j=1;j<=9;j++)
            {
                t=v[k][i];
                t*=10;
                m=0;
                t+=j;
                m=yang(t);
                if(m==1)
                    v[k+1].push_back(t);
            }
        }
    }
    for(i=0;i<v[n].size();i++)
    {
        cout<<v[n][i]<<endl;
    }
    return 0;
}
```

## 研究生第二次算法作业

### Problem A. 最小数字倍数
```
时间限制 1000 ms
内存限制 128 MB
题目描述
　　写一个程序，对于给定的一个自然数N（0≤N≤4999），以及M个不同的十进制数字X1,X2...XM（M≥1 最多10个数字），找出一个由X1,X2..XM组成的整数P，使得P是N的严格的倍数，且要求P最小。

输入数据
第一行为一个整数 N 。第二行为一个整数 M 。此后的 M 行分别为 M 个数字 X1,X2..XM 。
输出数据
输出一个整数 P （占一行），保证有解。
样例输入
22
3
7
0
1
样例输出
110
```

代码：
```
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <queue>
#include <string>
#include <map>
#include <cstring>
#include <ctime>
#include <vector>
#define inf 1e9
#define ll long long
#define For(i,j,k) for(int i=j;i<=k;i++)
#define Dow(i,j,k) for(int i=k;i>=j;i--)
using namespace std;
int n,m,a[101],q[10001],num[10001],nxt[10001],vis[10001],l=1,r,ans,tot,ANS[10001];
int main()
{
    scanf("%d%d",&n,&m);
    For(i,1,m)  scanf("%d",&a[i]);
    sort(a+1,a+m+1);
    For(i,1,m)  if(a[i]&&!vis[a[i]%n])  q[++r]=a[i]%n,vis[a[i]%n]=1,num[r]=a[i],nxt[r]=-1;
    while(l<=r)
    {
        int t=q[l];
        if(t==0){ans=l;break;}
        For(i,1,m)
        {
            int tmp=(t*10+a[i])%n;
            if(!vis[tmp])
                q[++r]=tmp,num[r]=a[i],nxt[r]=l,vis[tmp]=1;
        }
        l++;
    }
    while(ans!=-1)
    {
        ANS[++tot]=num[ans];
        ans=nxt[ans];
    }
    Dow(i,1,tot)    printf("%d",ANS[i]);
}
     

```

### Problem B. Warcraft III 守望者的烦恼
```
时间限制 1000 ms
内存限制 128 MB
题目描述
头脑并不发达的warden最近在思考一个问题，她的闪烁技能是可以升级的，k级的闪烁技能最多可以向前移动k个监狱，一共有n个监狱要视察，她从入口进去，一路上有n个监狱，而且不会往回走，当然她并不用每个监狱都视察，但是她最后一定要到第n个监狱里去，因为监狱的出口在那里，但是她并不一定要到第1个监狱。
守望者warden现在想知道，她在拥有k级闪烁技能时视察n个监狱一共有多少种方案？

输入数据
第一行是闪烁技能的等级 k (1≤ k≤ 10)
第二行是监狱的个数 n (1≤ n≤ 231−1)
输出数据
由于方案个数会很多，所以输出它 mod 7777777后的结果就行了
样例输入
2
4
样例输出
5
样例说明
把监狱编号1 2 3 4,闪烁技能为2级，
一共有5种方案
→1→2→3→4
→2→3→4
→2→4
→1→3→4
→1→2→4

小提示：建议用int64，否则可能会溢出
```

代码：
```
#include<bits/stdc++.h>
using namespace std;
const int MOD=7777777;
int k,n;
struct node{
    long long a[12][12];
}c,ans;
inline node Mul1(node x,node y){
    node res;
    memset(res.a,0,sizeof(res.a));
    for(int i=1;i<=k;i++)
        for(int j=1;j<=1;j++)
            for(int l=1;l<=k;l++)
                res.a[i][j]=(res.a[i][j]+x.a[i][l]*y.a[l][j])%MOD;
    return res;
}
inline node Mul2(node x,node y){
    node res;
    memset(res.a,0,sizeof(res.a));
    for(int i=1;i<=k;i++)
        for(int j=1;j<=k;j++)
            for(int l=1;l<=k;l++)
                res.a[i][j]=(res.a[i][j]+x.a[i][l]*y.a[l][j])%MOD;
    return res;
}
int main(){
    cin>>k>>n;
    ans.a[k+1][1]=1;
    for(int i=1;i<=k;i++)
        for(int j=0;j<i;j++) ans.a[k-i+1][1]+=ans.a[k-j+1][1];
    for(int i=1;i<=k;i++) c.a[1][i]=1;
    for(int i=2;i<=k;i++) c.a[i][i-1]=1;
    if(n<=k) cout<<ans.a[k+1-n][1];
    else{
        n-=k;
        while(n){
            if(n&1) ans=Mul1(c,ans);
            c=Mul2(c,c);
            n>>=1;
        }
        cout<<ans.a[1][1];
    }
}
```


### Problem C. 新年趣事之玩具
```
时间限制 1000 ms
内存限制 128 MB
题目描述
　　今年春节，xiaomengxian回到了邵阳过年。刚准备进门时，突然发现院子里有个小孩在摆弄什么东西。走进一看，原来他在玩一种智力玩具，叫做“汉诺塔”。“汉诺塔”是这样一种玩具：有三个柱子，分别编号：#1，#2，#3。初始时，有N个直径不同的盘子放在第一根柱子上，且越底下的盘子直径越大。游戏的目的是把所有的盘子转移到第二根柱子上。约束条件是：任何时候都只能把小盘子放在大盘子上。
　　由于盘子数目比较多，小孩玩了很久都没有完成任务。于是，xiaomengxian走上前去，打开随身携带的笔记本电脑，运行了一个很久以前编写的程序。它的主要过程大致是这样的：
　　procedure hanoi(n:integer;from,to,temp:integer);
　　begin
　　 if n> 0 then
　　 begin
　　　　 hanoi(n-1,from,temp,to);
　　　　 writeln(n,from,to);
　　　　 hanoi(n-1,temp,to,from)
　　 end
　　end;
　　有了xiaomengxian的帮助，小孩很快就完成了任务。他在感谢xiaomengxian的同时，又问了一个问题，想考考xiaomengxian。这个问题就是，给出一个中间状态，能否很快的说出这是第几次移动后的状态？
为了描述方便，对于每一个中间状态，我们定义序列D。其中，Di表示第i小的盘子所在的柱子编号。显然，Di=1，2，3。
　　下面是N=3的例子：
　　

输入数据
　　第一行为一个整数 N （ 1≤ N≤ 31 ）
　　第二行为 N 个整数，用空格分开，表示序列 D 。
输出数据
　　一个整数，表示该状态是第几次移动后的结果。如果该状态不是由上述代码产生的中间状态，则输出“-1”。
样例输入
3
3 3 1
样例输出
3
```

代码：
```
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>

using namespace std;

int n,step=0;
int a[50];
bool ok=1;

void mov(int n,int from,int to,int temp)
{   

    if(!ok || n<=0) return;
    if(a[n]==from)
    {
        mov(n-1,from,temp,to);
    }
    else if(a[n]==to)
    {
        step+=pow(2,n-1);
        mov(n-1,temp,to,from);
    }
    else if(a[n]==temp)
    {   
        ok=0;
        return;
    }
    //cout<<n<<" "<<from<<" "<<to<<endl;
}

int main()
{
    ios::sync_with_stdio(0);
    cin>>n;
    for(int i=1;i<=n;i++)
      cin>>a[i];
    mov(n,1,2,3);
    if(ok)
      cout<<step;
    else
      cout<<"-1"; 
    return 0;
}
```

### Problem D. 逆序对加强版
```
时间限制 1000 ms
内存限制 128 MB
题目描述
　　SORT公司是一个专门为人们提供排序服务的公司，该公司的宗旨是：“顺序是最美丽的”。他们的工作是通过一系列移动，将某些物品按顺序摆好。他们的服务是通过工作量来计算的，即移动东西的次数。所以，在工作前必须先考察工作量，以便向用户提出收费数目。
　　用户并不需要知道精确的移动次数，实质上，大多数人都是凭感觉来认定这一列物品的混乱程度，根据SORT公司的经验，人们一般是根据“逆序对”的数目多少来称呼这一序列的混乱程度。假设我们将序列中第i件物品的参数定义为Ai，那么排序就是指将Ai，…，An从小到大排序。若i< j且Ai> Aj，则< i,j> 就为一个“逆序对”。　　
　　例如，数组（3，1，4，5，2）的“逆序对”有< 3，1> ，< 3，2> ，< 4，2> ，< 5，2> ，共4个

　　SORT公司请你写一个程序，在尽量短的时间内，统计出“逆序对”的数目。
[输入]n，A1，…，An，1< n< 1000000，Ai为小于1000000的正整数,请注意数据大小，模拟绝对会爆！
[输出]数列A1，…，An的“逆序对”数目，即“逆序数”
[输入输出样例]
　　输入：5 3 1 4 5 2
　　输出：4
```

代码：
```
#include<cstdio>
using namespace std;
int data[1000003];
int fu[1000003];
long long res = 0;
void qsort(int l, int r)
{
    if(l == r) return;
    int mid = l + (r - l) / 2;
    qsort(l, mid);
    qsort(mid + 1, r);
    int p1 = l, p2 = mid + 1;
    int p3 = l;
    while(p1 <= mid || p2 <= r)
    {
        if(p1 <= mid && p2 <= r)
        {
            if(data[p1] <= data[p2]) fu[p3++] = data[p1++];
            else 
            {
                res += (mid - p1 + 1);
                fu[p3++] = data[p2++];
            }
        }
        else if(p1 <= mid && p2 > r) fu[p3++] = data[p1++];
        else fu[p3++] = data[p2++];
    }
    for(int i = l; i <= r; i++)
    data[i] = fu[i]; 
}
int main()
{
    int n;
    scanf("%d", &n);
    for(int i = 1; i <= n; i++)
        scanf("%d", &data[i]);
    qsort(1, n);
    printf("%lld", res);
    return 0;
}
```

### Problem E. 课堂作业-6-3
```
时间限制 1000 ms
内存限制 64 MB
题目描述
李老师的lucky number 是3，5和7，他爱屋及乌，还把所有质因数只有3，5，7的数字认定为lucky number，比如9, 15, 21, 25等等。请聪明的你帮忙算一算小于等于x的lucky number有多少个？

输入数据
一个正整数x，3=<x<=1000000000000

输出数据
小于等于x的lucky number的个数。

样例输入
49
样例输出
11
样例说明
int存不下
```
代码：
```
```

### Problem F. 课堂作业-7-4
```
时间限制 5000 ms
内存限制 64 MB
题目描述
对于一个长为n的数组A0,A1,A2......An-1，定义这个数组的得分为(A0 xor A1)+(A1 xor A2)+(A2 xor A3）+......+(An-2 xor An-1) ，即相邻两项的异或值的加和，比如数组1 1 2 2的得分为(1 xor 1) + (1 xor 2) + (2 xor 2) = 0+3+0 = 3
现在你可以重新排列这个数组，问最大得分是多少

输入数据
第一行为数组长度n，1=<n<=10 第二行为n个数，代表这个数组，每个数不超过1e9

输出数据
最大的得分是多少

样例输入
4
1 1 2 2
样例输出
9
样例说明
可以用STL函数next_permutation
```

代码：
```
```
