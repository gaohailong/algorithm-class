## 课堂作业一

### Problem A. 课堂作业-9-1
```
时间限制 1000 ms
内存限制 64 MB
题目描述
楼梯有n阶，可以一步上一阶、两阶或三阶，问有多少种不同的走法
由于答案很大，mod(1e9+7)输出

输入数据
一个正整数n，代表楼梯的阶数，n<=1000000

输出数据
方案数

样例输入
3
样例输出
4
```


代码：
```

```
### Problem B. 全排列

```
时间限制 1000 ms
内存限制 128 MB
题目描述
输入两个自然数m,n 1< =n< =20，1< =m< =n!
输出n个数的第m种全排列。
如 ：
输入 3 1
输出 1 2 3

输入数据
在一行中输入 n m
输出数据
一个数列,既 n 个数的第 m 种排列
每两个数之间空 1 格
样例输入
3 2
样例输出
1 3 2
```


代码：
```
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

int main() {
	 int n;
	 long m;
	 cin >> n;
	 cin >> m;
	
	 long long *array = new long long[n + 1];
	 long long sum = 1;
	 array[0] = 1;
	
	 
	 for (int i = 1; i <= n; i++) {
		  sum *= i;
		  array[i] = sum;
	 } 
	 int a[20] = {0};
	 for (int i = 0; i < n; i++) {
	 	 a[i]=i + 1;
	 }
	 vector<int> nums(a, a + n);
	 
	 vector<int>nums2;
	 nums2.reserve(1000);
	 m--;
	 for (int i = 1; i <= n; i++) {
		  int index = m / array[n - i];
		  nums2.push_back(nums[index]);
		  auto it = remove(nums.begin(), nums.end(), nums[index]);
		  nums.erase(it, nums.end());
		  m = m % array[n - i];
	 }
	 auto it = nums2.begin();
	 for (int i = 0; i < n; i++)
	 {
		  cout << *it << " ";
		  it++;
	 }
	 cout << endl;
	 return 0;
}
```

## 研究生算法第一次课下作业
Problem A. 数的计数
```
时间限制 1000 ms
内存限制 128 MB
题目描述
　　我们要求找出具有下列性质数的个数(包含输入的自然数n):
　　先输入一个自然数n(n≤1000)，然后对此自然数按照如下方法进行处理
　　 l·不作任何处理:
　　2·茬它的左边加上一个自然数，但该自然数不能超过原数的一半;
　　3·加上数后，继续按此规则进行处理，直到不能再立生自然数为止。

输入数据
输出数据
样例输入
6
样例输出
6
```
代码：
```
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1005;
 
int n,f[maxn]={1},ans;
 
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		for(int j=0;j<=i/2;j++)
			f[i] += f[j];
	cout<<f[n]<<endl;
	return 0;
}
```
### Problem B. 均分纸牌
```
时间限制 1000 ms
内存限制 128 MB
题目描述
有 N 堆纸牌，编号分别为 1，2，…, N。每堆上有若干张，但纸牌总数必为 N 的倍数。可以在任一堆上取若于张纸牌，然后移动。
　　移牌规则为：在编号为 1 堆上取的纸牌，只能移到编号为 2 的堆上；在编号为 N 的堆上取的纸牌，只能移到编号为 N-1 的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。
　　现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。

　　例如 N=4，4 堆纸牌数分别为：
　　①　9　②　8　③　17　④　6
　　移动3次可达到目的：
　　从 ③ 取 4 张牌放到 ④ （9 8 13 10） -> 从 ③ 取 3 张牌放到 ②（9 11 10 10）-> 从 ② 取 1 张牌放到①（10 10 10 10）。

输入数据
N （ N  堆纸牌， 1 ≤ N ≤ 100 ）
A1 A2 … An （ N  堆纸牌，每堆纸牌初始数， l≤ Ai < 104 ）
输出数据
所有堆均达到相等时的最少移动次数。
样例输入
4
9 8 17 6
样例输出
3
```
代码：
```

#include <stdio.h>
int n;//纸牌堆数
int poke[100];
int count=0;
 
void move(int aver,int k)//移动纸牌，思路就是将每一堆排都变成均值排数
{
	int a;
	a=aver - poke[k];
	poke[k] += a;
	poke[k+1] -= a;
	count++;
	while(poke[k] == aver)
	k++;
	if(k < n)
	move(aver,k);
}
int main()
{
	int i,k;
	int aver;
	scanf("%d",&n);
	for(i=0;i < n;i++)
	{
		scanf("%d",&poke[i]);
		aver+=poke[i];
	}
	aver=aver/n;
	k=n;
	for(i=0;i < n;i++)
	{
		if(poke[i] != aver)
		{
			k=i;
			break;
		}
	}
	if(k < n)
	move(aver,k);
	printf("%d",count);
	return 0;
} 
```

### Problem C. Superprime
```
时间限制 1000 ms
内存限制 128 MB
题目描述
农民约翰的母牛总是生产出最好的肋骨。你能通过农民约翰和美国农业部标记在每根肋骨上的数字认出它们。
农民约翰确定他卖给买方的是真正的质数肋骨,是因为从右边开始切下肋骨,每次还剩下的肋骨上的数字都组成一个质数,举例来说:
7 3 3 1
全部肋骨上的数字 7331是质数;三根肋骨 733是质数;二根肋骨 73 是质数;当然,最后一根肋骨 7 也是质数。

7331 被叫做长度 4 的特殊质数。
写一个程序对给定的肋骨的数目 N (1< =N< =8),求出所有的特殊质数。数字1不被看作一个质数。

输入数据
单独的一行包含 N 。
输出数据
按顺序输出长度为  N  的特殊质数,每行一个。
并按大小顺序排列(从小到大).
样例输入
4
样例输出
2333
2339
2393
2399
2939
3119
3137
3733
3739
3793
3797
5939
7193
7331
7333
7393
```
代码：
```

#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <queue>
#include <vector>
using namespace std;
typedef long long ll;
vector<ll>  v[10];
#define MAX 1e9+7
ll yang(ll m)
{
    ll i;
    ll k;
    k=sqrt(m);
    for(i=2; i<=k; i++)
        if(m%i==0)
            break;
    if(i==k+1)
        return 1;
    else
        return 0;
}
int main()
{
    ll i,k,t,n,m=0,j,ans[10101]={0};
    cin>>n;
    v[1].push_back(2);
    v[1].push_back(3);
    v[1].push_back(5);
    v[1].push_back(7);
    for(k=1;k<=7;k++)
    {
        for(i=0;i<v[k].size();i++)
        {
            for(j=1;j<=9;j++)
            {
                t=v[k][i];
                t*=10;
                m=0;
                t+=j;
                m=yang(t);
                if(m==1)
                    v[k+1].push_back(t);
            }
        }
    }
    for(i=0;i<v[n].size();i++)
    {
        cout<<v[n][i]<<endl;
    }
    return 0;
}
```

## 研究生第二次算法作业

### Problem A. 最小数字倍数
```
时间限制 1000 ms
内存限制 128 MB
题目描述
　　写一个程序，对于给定的一个自然数N（0≤N≤4999），以及M个不同的十进制数字X1,X2...XM（M≥1 最多10个数字），找出一个由X1,X2..XM组成的整数P，使得P是N的严格的倍数，且要求P最小。

输入数据
第一行为一个整数 N 。第二行为一个整数 M 。此后的 M 行分别为 M 个数字 X1,X2..XM 。
输出数据
输出一个整数 P （占一行），保证有解。
样例输入
22
3
7
0
1
样例输出
110
```

代码：
```
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <queue>
#include <string>
#include <map>
#include <cstring>
#include <ctime>
#include <vector>
#define inf 1e9
#define ll long long
#define For(i,j,k) for(int i=j;i<=k;i++)
#define Dow(i,j,k) for(int i=k;i>=j;i--)
using namespace std;
int n,m,a[101],q[10001],num[10001],nxt[10001],vis[10001],l=1,r,ans,tot,ANS[10001];
int main()
{
    scanf("%d%d",&n,&m);
    For(i,1,m)  scanf("%d",&a[i]);
    sort(a+1,a+m+1);
    For(i,1,m)  if(a[i]&&!vis[a[i]%n])  q[++r]=a[i]%n,vis[a[i]%n]=1,num[r]=a[i],nxt[r]=-1;
    while(l<=r)
    {
        int t=q[l];
        if(t==0){ans=l;break;}
        For(i,1,m)
        {
            int tmp=(t*10+a[i])%n;
            if(!vis[tmp])
                q[++r]=tmp,num[r]=a[i],nxt[r]=l,vis[tmp]=1;
        }
        l++;
    }
    while(ans!=-1)
    {
        ANS[++tot]=num[ans];
        ans=nxt[ans];
    }
    Dow(i,1,tot)    printf("%d",ANS[i]);
}
     

```

### Problem B. Warcraft III 守望者的烦恼
```
时间限制 1000 ms
内存限制 128 MB
题目描述
头脑并不发达的warden最近在思考一个问题，她的闪烁技能是可以升级的，k级的闪烁技能最多可以向前移动k个监狱，一共有n个监狱要视察，她从入口进去，一路上有n个监狱，而且不会往回走，当然她并不用每个监狱都视察，但是她最后一定要到第n个监狱里去，因为监狱的出口在那里，但是她并不一定要到第1个监狱。
守望者warden现在想知道，她在拥有k级闪烁技能时视察n个监狱一共有多少种方案？

输入数据
第一行是闪烁技能的等级 k (1≤ k≤ 10)
第二行是监狱的个数 n (1≤ n≤ 231−1)
输出数据
由于方案个数会很多，所以输出它 mod 7777777后的结果就行了
样例输入
2
4
样例输出
5
样例说明
把监狱编号1 2 3 4,闪烁技能为2级，
一共有5种方案
→1→2→3→4
→2→3→4
→2→4
→1→3→4
→1→2→4

小提示：建议用int64，否则可能会溢出
```

代码：
```
#include<bits/stdc++.h>
using namespace std;
const int MOD=7777777;
int k,n;
struct node{
    long long a[12][12];
}c,ans;
inline node Mul1(node x,node y){
    node res;
    memset(res.a,0,sizeof(res.a));
    for(int i=1;i<=k;i++)
        for(int j=1;j<=1;j++)
            for(int l=1;l<=k;l++)
                res.a[i][j]=(res.a[i][j]+x.a[i][l]*y.a[l][j])%MOD;
    return res;
}
inline node Mul2(node x,node y){
    node res;
    memset(res.a,0,sizeof(res.a));
    for(int i=1;i<=k;i++)
        for(int j=1;j<=k;j++)
            for(int l=1;l<=k;l++)
                res.a[i][j]=(res.a[i][j]+x.a[i][l]*y.a[l][j])%MOD;
    return res;
}
int main(){
    cin>>k>>n;
    ans.a[k+1][1]=1;
    for(int i=1;i<=k;i++)
        for(int j=0;j<i;j++) ans.a[k-i+1][1]+=ans.a[k-j+1][1];
    for(int i=1;i<=k;i++) c.a[1][i]=1;
    for(int i=2;i<=k;i++) c.a[i][i-1]=1;
    if(n<=k) cout<<ans.a[k+1-n][1];
    else{
        n-=k;
        while(n){
            if(n&1) ans=Mul1(c,ans);
            c=Mul2(c,c);
            n>>=1;
        }
        cout<<ans.a[1][1];
    }
}
```


### Problem C. 新年趣事之玩具
```
时间限制 1000 ms
内存限制 128 MB
题目描述
　　今年春节，xiaomengxian回到了邵阳过年。刚准备进门时，突然发现院子里有个小孩在摆弄什么东西。走进一看，原来他在玩一种智力玩具，叫做“汉诺塔”。“汉诺塔”是这样一种玩具：有三个柱子，分别编号：#1，#2，#3。初始时，有N个直径不同的盘子放在第一根柱子上，且越底下的盘子直径越大。游戏的目的是把所有的盘子转移到第二根柱子上。约束条件是：任何时候都只能把小盘子放在大盘子上。
　　由于盘子数目比较多，小孩玩了很久都没有完成任务。于是，xiaomengxian走上前去，打开随身携带的笔记本电脑，运行了一个很久以前编写的程序。它的主要过程大致是这样的：
　　procedure hanoi(n:integer;from,to,temp:integer);
　　begin
　　 if n> 0 then
　　 begin
　　　　 hanoi(n-1,from,temp,to);
　　　　 writeln(n,from,to);
　　　　 hanoi(n-1,temp,to,from)
　　 end
　　end;
　　有了xiaomengxian的帮助，小孩很快就完成了任务。他在感谢xiaomengxian的同时，又问了一个问题，想考考xiaomengxian。这个问题就是，给出一个中间状态，能否很快的说出这是第几次移动后的状态？
为了描述方便，对于每一个中间状态，我们定义序列D。其中，Di表示第i小的盘子所在的柱子编号。显然，Di=1，2，3。
　　下面是N=3的例子：
　　

输入数据
　　第一行为一个整数 N （ 1≤ N≤ 31 ）
　　第二行为 N 个整数，用空格分开，表示序列 D 。
输出数据
　　一个整数，表示该状态是第几次移动后的结果。如果该状态不是由上述代码产生的中间状态，则输出“-1”。
样例输入
3
3 3 1
样例输出
3
```

代码：
```
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>

using namespace std;

int n,step=0;
int a[50];
bool ok=1;

void mov(int n,int from,int to,int temp)
{   

    if(!ok || n<=0) return;
    if(a[n]==from)
    {
        mov(n-1,from,temp,to);
    }
    else if(a[n]==to)
    {
        step+=pow(2,n-1);
        mov(n-1,temp,to,from);
    }
    else if(a[n]==temp)
    {   
        ok=0;
        return;
    }
    //cout<<n<<" "<<from<<" "<<to<<endl;
}

int main()
{
    ios::sync_with_stdio(0);
    cin>>n;
    for(int i=1;i<=n;i++)
      cin>>a[i];
    mov(n,1,2,3);
    if(ok)
      cout<<step;
    else
      cout<<"-1"; 
    return 0;
}
```

### Problem D. 逆序对加强版
```
时间限制 1000 ms
内存限制 128 MB
题目描述
　　SORT公司是一个专门为人们提供排序服务的公司，该公司的宗旨是：“顺序是最美丽的”。他们的工作是通过一系列移动，将某些物品按顺序摆好。他们的服务是通过工作量来计算的，即移动东西的次数。所以，在工作前必须先考察工作量，以便向用户提出收费数目。
　　用户并不需要知道精确的移动次数，实质上，大多数人都是凭感觉来认定这一列物品的混乱程度，根据SORT公司的经验，人们一般是根据“逆序对”的数目多少来称呼这一序列的混乱程度。假设我们将序列中第i件物品的参数定义为Ai，那么排序就是指将Ai，…，An从小到大排序。若i< j且Ai> Aj，则< i,j> 就为一个“逆序对”。　　
　　例如，数组（3，1，4，5，2）的“逆序对”有< 3，1> ，< 3，2> ，< 4，2> ，< 5，2> ，共4个

　　SORT公司请你写一个程序，在尽量短的时间内，统计出“逆序对”的数目。
[输入]n，A1，…，An，1< n< 1000000，Ai为小于1000000的正整数,请注意数据大小，模拟绝对会爆！
[输出]数列A1，…，An的“逆序对”数目，即“逆序数”
[输入输出样例]
　　输入：5 3 1 4 5 2
　　输出：4
```

代码：
```
#include<cstdio>
using namespace std;
int data[1000003];
int fu[1000003];
long long res = 0;
void qsort(int l, int r)
{
    if(l == r) return;
    int mid = l + (r - l) / 2;
    qsort(l, mid);
    qsort(mid + 1, r);
    int p1 = l, p2 = mid + 1;
    int p3 = l;
    while(p1 <= mid || p2 <= r)
    {
        if(p1 <= mid && p2 <= r)
        {
            if(data[p1] <= data[p2]) fu[p3++] = data[p1++];
            else 
            {
                res += (mid - p1 + 1);
                fu[p3++] = data[p2++];
            }
        }
        else if(p1 <= mid && p2 > r) fu[p3++] = data[p1++];
        else fu[p3++] = data[p2++];
    }
    for(int i = l; i <= r; i++)
    data[i] = fu[i]; 
}
int main()
{
    int n;
    scanf("%d", &n);
    for(int i = 1; i <= n; i++)
        scanf("%d", &data[i]);
    qsort(1, n);
    printf("%lld", res);
    return 0;
}
```

### Problem E. 课堂作业-6-3
```
时间限制 1000 ms
内存限制 64 MB
题目描述
李老师的lucky number 是3，5和7，他爱屋及乌，还把所有质因数只有3，5，7的数字认定为lucky number，比如9, 15, 21, 25等等。请聪明的你帮忙算一算小于等于x的lucky number有多少个？

输入数据
一个正整数x，3=<x<=1000000000000

输出数据
小于等于x的lucky number的个数。

样例输入
49
样例输出
11
样例说明
int存不下
```
代码：
```
#include<stdio.h>
#include<math.h>
#include<iomanip>
#include "stdlib.h"
#include <iostream>
using namespace std;
long rooting(long x, int a);
int main(){
    long x;
    long count = 0;
    cin >> x;

    long three_times =rooting(x,3);
    long five_times = rooting(x, 5);
    long seven_times = rooting(x,7);

    //count = three_times + five_times + seven_times;

    for (long i = 0; i <three_times + 1; i++)
        for (long j = 0; j < five_times + 1; j++)
            for (long k = 0; k < seven_times + 1; k++){
                if ((pow(3, i)* pow(5, j) * pow(7, k) <= x) && (i + j + k)>0) {
                    count = count + 1;
                    //cout << "i:" << i << "  j:" << j << "  k:" << k << endl;
                }
            }
    cout << count << endl;
    return 0;
}

long rooting(long x, int a){
    int three_m = x % a;
    x = x - three_m;
    long times = 0;
    while (x > 1){
        x = x / a;
        times = times + 1;
    }
    return times;
}
```

### Problem F. 课堂作业-7-4
```
时间限制 5000 ms
内存限制 64 MB
题目描述
对于一个长为n的数组A0,A1,A2......An-1，定义这个数组的得分为(A0 xor A1)+(A1 xor A2)+(A2 xor A3）+......+(An-2 xor An-1) ，即相邻两项的异或值的加和，比如数组1 1 2 2的得分为(1 xor 1) + (1 xor 2) + (2 xor 2) = 0+3+0 = 3
现在你可以重新排列这个数组，问最大得分是多少

输入数据
第一行为数组长度n，1=<n<=10 第二行为n个数，代表这个数组，每个数不超过1e9

输出数据
最大的得分是多少

样例输入
4
1 1 2 2
样例输出
9
样例说明
可以用STL函数next_permutation
```

代码：
```

#include<bits/stdc++.h>
using namespace std;

int main(int argc, char** argv) {
	 int n;
	 cin>>n;
	 long long  a[10];
	 for(int i=0;i<n;i++){
	  	cin>>a[i];
	 }
	 long long max=0;
	 sort(a,a+n);
	 do{
	 // cout<<a[0]<<a[1]<<a[2]<<a[3]<<endl;
		  long long tmp=0;
			  for(int i=0;i<n-1;i++){
			    tmp+=a[i]^a[i+1];
			  }
		  if(max<tmp){
		 	  max=tmp;
		  }
	 }while(next_permutation(a,a+n));
	 cout<<max<<endl; 
	 return 0;
}
```

## 研究生第三次算法作业

### Problem A. 伊甸园日历游戏
```
时间限制 1000 ms
内存限制 128 MB
题目描述
Adam和Eve玩一个游戏，他们先从1900.1.1到2001.11.4这个日期之间随意抽取一个日期出来。然后他们轮流对这个日期进行操作：

1 ： 把日期的天数加1，例如1900.1.1变到1900.1.2

2 ： 把月份加1，例如：1900.1.1变到1900.2.1

其中如果天数超过应有天数则日期变更到下个月的第1天。月份超过12则变到下一年的1月。而且进行操作二的时候，如果有这样的日期：1900.1.31，则变成了1900.2.31，这样的操作是非法的，我们不允许这样做。而且所有的操作均要考虑历法和闰年的规定。

谁先将日期变到2001.11.4谁就赢了。

每次游戏都是Adam先操作，问他有没有必胜策略？

输入数据
一个测试点。多组数据。
第一行为数据组数。
接下来一行 X Y Z 表示 X 年 Y 月 Z 日
输出数据
输出“YES”or“NO”表示亚当是否有必胜策略。
样例输入
3
2001 11 3
2001 11 2
2001 10 3
样例输出
YES
NO
NO
```
代码：
```
#include<bits/stdc++.h>
using namespace std;
int main(){
	int T;
	int y,m,d;
	cin>>T;
	while(T--){
		cin>>y>>m>>d;
		if((m==9&&d==30)||(m==11&&d==30)||(m+d)%2==0){
			cout<<"YES"<<endl;
		}else{
			cout<<"NO"<<endl;
		}
	}
	return 0;
}
```

### Problem B. 吃糖果游戏
```
题目描述
　　Matrix67和Shadow正在做一个小游戏。
　　桌子上放着两堆糖果，Matrix67和Shadow轮流对这些糖果进行操作。在每一次操作中，操作者需要吃掉其中一堆糖果，并且把另一堆糖果分成两堆（可以不相等）留给对方操作。游戏如此进行下去，糖果数会越来越少，最后必将出现这样一种情况：某人吃掉一堆糖果后发现另一堆里只剩一块糖果不能再分了。游戏规定此时该操作者吃掉最后这一块糖果从而取胜。
　　这个游戏是不公平的。对于任意一种初始状态，总有一方有必胜策略。所谓有必胜策略是指，无论对方如何操作，自己总有办法取胜。
　　Matrix67和Shadow将进行10次游戏，每一次游戏中总是Matrix67先进行操作。Matrix67想知道每一次游戏中谁有必胜策略。

输入数据
　　输入数据一共 10 行，每行有两个用空格隔开的正整数，表示一次游戏开始时桌子上两堆糖果分别有多少个。
　　对于 50 的数据，这些正整数均不超过100；
　　对于 70 的数据，这些正整数均不超过 10 000 ；
　　对于100%的数据，这些正整数均不超过 10 000 位。
输出数据
　　输出十行字符串。这些字符串只能是“Matrix67”或“Shadow”，它们表示对应的十行输入数据中有必胜策略的一方。
　　请注意大小写。
样例输入
1 1
1 2
1 3
1 4
1 5
2 1
2 2
2 3
2 4
2 5
样例输出
Matrix67
Matrix67
Matrix67
Matrix67
Matrix67
Matrix67
Shadow
Shadow
Matrix67
Matrix67
```
代码：
```
#include <iostream>
#include <cstdio>
using namespace std;
int main()
{
    int i=1;
    string a,b;
    char c,d;
    while(i<=10)
    {
        ++i;
        cin>>a;
        if(a=="-1")
        break;
        cin>>b;
        c=a[a.length()-1];
        d=b[b.length()-1];
        if((c=='2'||c=='3'||c=='7'||c=='8')&&(d=='2'||d=='3'||d=='7'||d=='8'))
        cout<<"Shadow\n";
        else
        cout<<"Matrix67\n";
    }
    return 0;
}
```

### Problem C. 欧几里德的游戏
```
题目描述
　　欧几里德的两个后代Stan和Ollie正在玩一种数字游戏，这个游戏是他们的祖先欧几里德发明的。给定两个正整数M和N，从Stan开始，从其中较大的一个数，减去较小的数的正整数倍，当然，得到的数不能小于0。然后是Ollie，对刚才得到的数，和M，N中较小的那个数，再进行同样的操作……直到一个人得到了0，他就取得了胜利。下面是他们用(25，7)两个数游戏的过程：
Start：25 7
Stan：11 7
Ollie：4 7
Stan：4 3
Ollie：1 3
Stan：1 0
Stan赢得了游戏的胜利。
现在，假设他们完美地操作，谁会取得胜利呢？

输入数据
第一行为测试数据的组数 C 。下面有 C 行，每行为一组数据，包含两个正整数 M, N 。（ M, N 不超过长整型。）
输出数据
对每组输入数据输出一行，如果Stan胜利，则输出“Stan wins”；否则输出“Ollie wins”
样例输入
2
25 7
24 15

样例输出
Stan wins
Ollie wins
```

代码：
```
#include<iostream>
using namespace std;
long long a,b,c;
int ans;
void dfs(int x,int y,int s)
{
    if(x>y)swap(x,y);
    if(y%x==0||y/x>1){ans=s;return;}
    dfs(x,y-x,(s+1)%2);
}
int main()
{
    cin>>c;
    while(c--)
    {
        ans=-1;
        cin>>a>>b,dfs(a,b,0);
        if(ans==0)cout<<"Stan wins"<<endl;
        if(ans==1)cout<<"Ollie wins"<<endl;
    }
}
```

### Problem D. 盒子与球
```
题目描述
现有r个互不相同的盒子和n个互不相同的球，要将这n个球放入r个盒子中，且不允许有空盒子。问有多少种方法？
例如：有2个不同的盒子（分别编为1号和2号）和3个不同的球（分别编为1、2、3号），则有6种不同的方法：
1号盒子　　1号球 1、2号球 1、3号球　　2号球 2、3号球　　3号球
2号盒子 2、3号球　　3号球　　2号球 1、3号球　　1号球 1、2号球

输入数据
两个整数， n 和 r ，中间用空格分隔。（0≤n, r≤10）
输出数据
N 臢 圠 �N N∗etep�O 輯罻  (�etW 媰  V 鬛 �0  坔 y: nN∗t e> Qe rN∗v 襕 Pv 別筶�

样例输入
3 2
样例输出
6
样例说明
第二类Stirling数。
```

代码：
```
#include<bits/stdc++.h>
using namespace std;
#define l long long
l al[11][11],n,r;
l jc(l a){
    l ans=1;
    for(int i=1;i<=a;i++)
        ans*=i;
    return ans;
}
int main(){
    cin>>n>>r;
    for(int i=0;i<=10;i++)
        al[i][i]=1;
    for(int i=1;i<=10;i++)
        al[i][0]=0;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=r;j++)
            al[i][j]=al[i-1][j-1]+al[i-1][j]*j;
    cout<<al[n][r]*jc(r);
    return 0;
}
```

### Problem E. Easy Selection
```
题目描述
这个游戏是这样的，wind先写下一排数。既然是一排，当然有首尾咯。
wind和小杉(lolanv)每次只能从这排数的头或尾取一个数。
最后谁取的数的和多，谁就赢了。如果两人的和一样多，先取者胜。

有天swgr看到他们俩在玩这个游戏，很好奇。
他想知道，在两人总是做出最优决策的情况下（两个人的智商都是很高的……），
谁能取得最终的胜利呢？

输入数据
第一行为一个数 k (k≤ 10) ，表示有 k 组测试数据。
以下 k 组测试数据。
每组测试数据中，第一行仅有一个偶数 n (0< n< 105)
第二行也仅有一个数， 0 表示wind先取数， 1 表示小杉  (lolanv) 先取数
第三行有 n 个数，是wind给出的一排数。这 n 个数的绝对值均不超过1e6
输出数据
对每组测试数据输出一行
表示在两人总是做出最优决策的情况下，
最终的胜利者的名字，即 " wind"  或 " lolanv"  （引号不输出）。
样例输入
2
2
1
1 3
2
0
1 3

样例输出
lolanv
wind
```
代码:
```
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
using namespace std;
//先取的人可以比较所有奇数位置数之和与所有偶数位置之和,哪个大就一直取相应的位置上的数....注意N为整数
//
//比如,6 1000 564 48 400 2
//
//奇数位置和为6+564+400=970 偶数位置和为1000+48+2=1050>970
//
//故先去的人可以先取2 后取的必定在奇数位置上取数(他只能取奇数位置的了)
//
//PS:先取的不一定是当前最优.......
int main()
{
    int k,q;
    scanf("%d",&k);
    for(q=1;q<=k;q++)
    {
        int n,who;
        int a;
        scanf("%d\n%d\n",&n,&who);
        for(int i=1;i<=n;i++)
        {
            scanf("%d",&a);
        }
        if(who==0)
            printf("wind\n");
        else
            printf("lolanv\n");
    }
    return 0;
}
```

## 课堂练习（二）
### Problem A. 肥猫的游戏

```
题目描述
　　野猫与胖子，合起来简称肥猫，是一个班的同学，他们也都是数学高手，所以经常在一起讨论数学问题也就不足为奇了。一次，野猫遇到了一道有趣的几何游戏题目，便拿给胖子看。游戏要求在一个有n个顶点凸多边形上进行，这个凸多边形的n-3条对角线将多边形分成n-2个三角形，这n-3条对角线在多边形的顶点相交。三角形中的一个被染成黑色，其余是白色。双方轮流进行游戏，当轮到一方时，他必须沿着画好的对角线，从多边形上切下一个三角形。切下黑色三角形的一方获胜。胖子一看觉得确实很有趣，不如就一起玩玩吧。假设游戏由野猫先开始，那么野猫是否有必胜的策略呢？请写一个程序帮助野猫算一算。

输入数据
第一行为一个整数 n (4≤ n< 5× 104) ，表示多边形的顶点数，多边形的顶点由 0 至 n－1 顺时针标号。接着的 n−2 行描述组成多边形的三角形。第 i+1 行  (1≤ i≤ n−2) 有三个空格分隔的非负整数a、b、c，它们是第 i 个三角形的顶点编号。第一个给出的三角形是黑色的。
输出数据
只有一行，倘若野猫有必胜策略，输出JMcat Win；否则，输出 PZ Win 。（注意大小写和空格）
样例输入
6
0 1 2
2 4 3
4 2 0
0 5 4
样例输出
JMcat Win
样例说明
如果连接一个多边形中任意两点的线段都完全包含于这个多边形，则称这个多边形为凸多边形。
```
代码

```
#include <iostream>
#include <cstdio>
#include <queue>
#include <algorithm>
#include <cmath>
#include <cstring>
#define inf 2147483647
#define N 1000010
#define p(a) putchar(a)
#define For(i,a,b) for(int i=a;i<=b;++i)
//by war
//2019.8.9
using namespace std;
int n;
int a[10];
int flag;
void in(int &x){
    int y=1;char c=getchar();x=0;
    while(c<'0'||c>'9'){if(c=='-')y=-1;c=getchar();}
    while(c<='9'&&c>='0'){ x=(x<<1)+(x<<3)+c-'0';c=getchar();}
    x*=y;
}
void o(int x){
    if(x<0){p('-');x=-x;}
    if(x>9)o(x/10);
    p(x%10+'0');
}

signed main(){
    in(n);
    in(a[1]);in(a[2]);in(a[3]);
    For(i,1,n-3)
        in(a[4]),in(a[5]),in(a[6]);
    sort(a+1,a+3+1);
    if(a[3]-a[2]==1&&a[2]-a[1]==1){
        puts("JMcat Win");
    }    
    else
        if((a[3]-a[2]==1&&a[2]-a[1]!=1) || (a[3]-a[2]!=1&&a[2]-a[1]==1) || (a[1]+a[3]==n-1 && (a[2]!=1||a[2]!=n-2))){
            if(n&1)
                puts("PZ Win");
            else
                puts("JMcat Win");
        }
    else
        if(a[3]-a[2]!=1 && a[2]-a[1]!=1){
            if(n&1)
                puts("PZ Win");
            else
                puts("JMcat Win");
        }
    return 0;
}
```

### Problem B. 课间十分钟
```
题目描述
两人都是数学爱好者，便发明了一个游戏。
在游戏开始前，他们先约定一个正整数n，同时令m=1。游戏过程中，每个人都可以将m的值扩大2到9中的任意倍数。第一个使m≥n的人就是最后的赢家。
181818181818和ZBT都十分聪明，并且游戏过程中都使用最佳的策略，问谁会是最后的赢家。（181818181818总是第一个先玩）

输入：一个正整数n（1≤n≤2^32-1）

输出：在使用最佳的策略的情况下，如果181818181818必胜，则输出“181818181818”。如果ZBT必胜，则输出“ZBT”。

输入数据
输出数据
样例输入
9
样例输出
181818181818
```

方法：
```
if __name__ == '__main__':
    n = int(input())
    m = 1
    while m < n:
        m = m * 18
    if n == 1:
        print("181818181818")
    elif n <= m / 2:
        print("181818181818")
    else:
        print("ZBT")
```


## 研究生第四次算法作业

### Problem A. 水王争霸
```
题目描述
众所周知，IOIForum有很多水王，他们的发贴数是如此之多，以至于必须要用高精度数才能保存。
为了迎接国庆，IOIForum决定举行一次水王争霸赛，比赛的规则是将这些水王截止到2003年9月30日23时59分59秒这一刻所发的总贴数从大到小进行排序。每个水王当然都想取得尽量靠前的名次，所以他们竭尽全力，不择手段地进行灌水。
终于，激动人心的一刻到来了，2003年10月1日0时0分0秒，你作为裁判得到了每个水王的发贴数，现在，你的任务是公正地把这些水王按照发贴数从大到小进行排序。

输入数据
输入的第一行是一个 1 到1000的整数 N ，表示总共有 N 位水王参加了争霸赛。
以下依次给出每位水王的描述，一位水王的描述占据两行，第一行为一个仅由字母和数字组成的长度不超过 20 的字符串，代表这个水王的 ID ，第二行一个高精度的整数(非负数)，代表这个水王的发贴数。注意，这个整数的首位没有不必要的 0 。
考虑到IOIForum的数据库是有限的，所有水王发贴数的总长度（注意，是总长度而不是总和）不会超�10^{4}。
除了子母、数字和必要的换行，输入中不会出现空格等字符。
输出数据
依次输出按照发贴数从大到小排好序的各位水王的 ID ，每个 ID 占据单独的一行。不能有任何多余的字符。若几个 ID 的发贴数相同，则按照 ID 的字典顺序先后排列。
样例输入
6
lowai
1534534124561243453
zhouyuan
23453265344
Maolaoda
23442353452342
BuTaoCaiGuai
7568784573464
ArthurKing
97534892734723947
hyyylr
623893451
样例输出
lowai
ArthurKing
Maolaoda
BuTaoCaiGuai
zhouyuan
hyyylr
```

代码：
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
struct node
{
    char name[25];
    char score[1005];
}king[10005];
bool cmp(node x,node y)
{
    if(strlen(x.score)<strlen(y.score))
        return 0;
    else if(strlen(x.score)==strlen(y.score))
    {
        if(strcmp(x.score,y.score)<0)
            return 0;
        if(strcmp(x.score,y.score)==0)
        {
            return strcmp(x.name,y.name)<0;
            return 1;
        }
    }
}
int main()
{
    int n;
    scanf("%d",&n);
    int i;
    for(i=0;i<n;i++)
    {
        scanf("%s%s",king[i].name,king[i].score);
    }
    sort(king,king+n,cmp);
    for(i=0;i<n;i++)
    {
        printf("%s\n",king[i].name);
    }
    return 0;
}
```

### Problem B. 佳佳的魔法照片
```
题目描述
一共有n个人（以1--n编号）向佳佳要照片，而佳佳只能把照片给其中的k个人。佳佳按照与他们的关系好坏的程度给每个人赋予了一个初始权值W[i]。然后将初始权值从大到小进行排序，每人就有了一个序号D[i]（取值同样是1--n）。按照这个序号对10取模的值将这些人分为10类。也就是说定义每个人的类别序号C[i]的值为(D[i]-1) mod 10 +1，显然类别序号的取值为1--10。第i类的人将会额外得到E[i]的权值。你需要做的就是求出加上额外权值以后，最终的权值最大的k个人，并输出他们的编号。在排序中，如果两人的W[i]相同，编号小的优先。

输入数据
第一行输出用空格隔开的两个整数，分别是 n 和 k 。
第二行给出了 10 个正整数，分别是 E[1] 到 E[10] 。
第三行给出了 n 个正整数，第 i 个数表示编号为 i 的人的权值 W[i] 。
输出数据
只需输出一行用空格隔开的 k 个整数，分别表示最终的 W[i] 从高到低的人的编号。
样例输入
10 10
1 2 3 4 5 6 7 8 9 10
2 4 6 8 10 12 14 16 18 20
样例输出
10 9 8 7 6 5 4 3 2 1
样例说明
对于50%的数据，n< =200；
对于100%的数据，n< =50 000，k< =2000，给出的所有正整数都不超过32767。
```

代码：
```
#include<iostream>
#include<algorithm>
using namespace std;
struct data
{
       int num,w,d;
       }a[5000001];
inline bool cp(data a,data b)
{
    return (a.w==b.w)?a.num<b.num:a.w>b.w;
}
int main()
{
	int n,k,e[11];
	cin>>n>>k;
	for(int i=1;i<=10;i++)
	   cin>>e[i];
	for(int i=1;i<=n;i++)
	{
            a[i].num=i;
            cin>>a[i].w;
            }
    sort(a+1,a+n+1,cp);
    for(int i=1;i<=n;i++)
            a[i].w+=e[(i-1)%10+1];
    sort(a+1,a+n+1,cp);
    for(int i=1;i<=k;i++) 
    {
       cout<<a[i].num<<' ';
       }   
    return 0;
}
```


### Problem C. 大整数
```
题目描述
一个k(1< =k< =80)位的十进制正整数N,就是所谓的大整数.
请你设计程序,对于给出的某一个大整数N,找到满足p^3+p^2+3p< =n的p的最大值.

输入数据
输入数据只有一行，是一个 K 位的大整数 N ，行首行未无多余空格
输出数据
输出第一行为你所找到的 P 最大值，行首行末别乱加东西
样例输入
1000000000000001000000000000003000000000000001
样例输出
1000000000000000
```
代码(代码不好)
```
def main():
    number = int(input())
    left = 0
    right = number
    while left < right:
        mid = left + (right - left) // 2
        if mid == left:
            break
        if mid * mid * mid + mid * mid + mid * 3 <= number:
            left = mid
        else:
            right = mid
    print(left)

if __name__ == '__main__':
    main()
```

### Problem D. 奖学金
```
题目描述
　　某小学最近得到了一笔赞助，打算拿出其中一部分为学习成绩优秀的前5名学生发奖学金。期末，每个学生都有3门课的成绩：语文、数学、英语。先按总分从高到低排序，如果两个同学总分相同，再按语文成绩从高到低排序，如果两个同学总分和语文成绩都相同，那么规定学号小的同学排在前面，这样，每个学生的排序是唯一确定的。
　　任务：先根据输入的3门课的成绩计算总分，然后按上述规则排序，最后按排名顺序输出前5名学生的学号和总分。注意，在前5名同学中，每个人的奖学金都不相同，因此，你必须严格按上述规则排序。例如，在某个正确答案中，如果前两行的输出数据(每行输出两个数：学号、总分)是：
　　7 279
　　5 279
　　这两行数据的含义是：总分最高的两个同学的学号依次是7号、5号。这两名同学的总分都是279(总分等于输入的语文、数学、英语三科成绩之和)，但学号为7的学生语文成绩更高一些。如果你的前两名的输出数据是：
　　5 279
　　7 279
　　则按输出错误处理，不能得分。

输入数据
　　输入包含 n+1 行：
　　第 l 行为一个正整数 n ，表示该校参加评选的学生人数。
　　第 2 到年 n+l 行，每行有 3 个用空格隔开的数字，每个数字都在 0 到100之间。第 j 行的 3 个数字依次表示学号为 j−1 的学生的语文、数学、英语的成绩。每个学生的学号按照输入顺序编号为 1～n ( 恰好是输入数据的行号减 1) 。
　　所给的数据都是正确的，不必检验。
输出数据
　　输出共有 5 行，每行是两个用空格隔开的正整数，依次表示前 5 名学生的学号和总分。
样例输入
Sample 1:
6
90 67 80
87 66 91
78 89 91
88 99 77
67 89 64
78 89 98

Sample 2:
8
80 89 89
88 98 78
90 67 80
87 66 91
78 89 91
88 99 77
67 89 64
78 89 98
样例输出
Sample 1:
6 265
4 264
3 258
2 244
1 237

Sample 2:
8 265
2 264
6 264
1 258
5 258
样例说明
50%的数据满足：各学生的总成绩各不相同
100%的数据满足：6< =n< =300
```
代码:
```
#include<iostream>
#include<algorithm>
using namespace std;
struct stu
{
int xh,ch,math,eng,sum;
};
bool cmp(stu x,stu y)
{
if(x.sum>y.sum) return true;
else if(x.sum==y.sum&&x.ch>y.ch) return true;
else if(x.sum==y.sum&&x.ch==y.ch&&x.xh<y.xh) return true;
else return false;
}
int main()
{
int n;
cin>>n;
stu student[301];
for(int i=0;i<n;i++)
{
cin>>student[i].ch>>student[i].math>>student[i].eng;
student[i].sum=student[i].ch+student[i].math+student[i].eng;
student[i].xh=i+1;
}
sort(student,student+n,cmp);
for(int i=0;i<5;i++)
{
cout<<student[i].xh<<" "<<student[i].sum<<endl;
}
return 0;
}
```

### Problem E. 遭遇战
```
题目描述
今天，他们在打一张叫DUSTII的地图，万恶的恐怖分子要炸掉藏在A区的SQC论坛服务器！我们SQC的人誓死不屈，即将于恐怖分子展开激战，准备让一个人守着A区，这样恐怖分子就不能炸掉服务器了。（一个人就能守住??这人是机械战警还是霹雳游侠？）
但是问题随之出现了，由于DustII中风景秀丽，而且不收门票，所以n名反恐精英们很喜欢在这里散步，喝茶。他们不愿意去单独守在荒无人烟的A区，在指挥官的一再命令下，他们终于妥协了，但是他们每个人都要求能继续旅游，于是给出了自己的空闲时间，而且你强大的情报系统告诉了你恐怖份子计划的进攻时间（从s时刻到e时刻）。
当然，精明的SQC成员不会为你免费服务，他们还要收取一定的佣金（注意，只要你聘用这个队员，不论他的执勤时间多少，都要付所有被要求的佣金）。身为指挥官的你，看看口袋里不多的资金（上头真抠！），需要安排一个计划，雇佣一些队员，让他们在保证在进攻时间里每时每刻都有人员执勤，花费的最少资金。

输入数据
第一行是三个整数n(1≤n�10^{4})，s和e（1≤s≤e�9\times 10^{4}）。
接下来n行，描述每个反恐队员的信息：空闲的时间si, ei（1≤si≤ei�9\times 10^{4}）和佣金ci（1≤ci�3\times 10^{5}）。
输出数据
一个整数，最少需支付的佣金，如果无解，输出“-1”。
样例输入
3 1 5
1 3 3
4 5 2
1 1 1
样例输出
5
样例说明
敌人从1时刻到4时刻要来进攻，一共有3名反恐队员。第1名从1时刻到3时刻有空，要3元钱（买糖都不够??）。以此类推。
一共要付5元钱，选用第1名和第2名。
```
代码：
```
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<queue>
#include<vector>
using namespace std;
const int maxn=10010;
const long long inf=1000000000000LL;
struct node{
    int l;
    int r;
    long long c;
    bool operator > (const node &a)const
    {
	return c>a.c;
    }
}a[maxn];
int n,s,e,m;
long long t[300010*4],val;
priority_queue<node, vector<node>, greater<node> > q;
bool cmp(node a,node b){
    if(a.l==b.l)
	return a.r<b.r;
    return a.l<b.l;
}
int main(){
    while(scanf("%d%d%d",&n,&s,&e)!=EOF){
	for(int i=0;i<n;i++)
	    scanf("%d%d%lld",&a[i].l,&a[i].r,&a[i].c);
	sort(a,a+n,cmp);
	if(a[0].l>s)
	{
	    printf("-1\n");
	    continue;
	}
	q.push(a[0]);
	long long ans=inf;
	for(int i=1;i<n;i++)
	{
	    while(!q.empty())
	    {
		node ita=q.top();
		if(ita.r>=e)
		{
		    ans=ita.c;
		    break;
		}
		if(ita.r>=a[i].l-1)
		{
		    if(ita.l<a[i].l)
			a[i].c+=ita.c;
		    q.push(a[i]);
		    break;
		}
		else
		    q.pop();
	    }
	}
	while(!q.empty())
	{
	    node ita=q.top();
	    q.pop();
	    if(ans==inf&&ita.r>=e)
		ans=ita.c;
	}
	if(ans==inf)
	    printf("-1\n");
	else
	    printf("%lld\n",ans);
    }
    return 0;
}
```

###
```
题目描述
笨笨有一些单词，他想要把这些单词按一定顺序排序。

现在笨笨有N(N< =1000)个单词，他想要你按笨笨的字典序把这些单词顺序或逆序排列好来。

输入笨笨的字典序以及他所要排序的单词和他所要的排序方式（顺序或逆序，顺序用1表示，逆序用0表示）。

请你把排好的单词输出,每个单词长度不超过255个字符,中间没有空格。

输入数据
第一行，一个长度为 26 的字母不重复的字符串，表示笨笨的字典序（ 26 个字母全齐）。
第二行一个数 N 。
接下来 N 行，每行一个单词。
最后一行是笨笨所想要的排序方式。
输出数据
输出共 N 行，表示排好序的单词。输出每行一个单词。
样例输入
abcdefghijklmnopqrstuvwxyz
2
big
small
1
样例输出
big
small
样例说明
是笨笨的字典序，不是一般的字典序哦。
输入输出中的字母均为小写字母。
注：顺序逆序就是说把它们按一定的顺序排列好，而不是要你把单词反过来。
如（按字典序）：
顺序为：
aa
ba
ca
逆序为
ca
ba
aa
```
代码：
```
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>

using namespace std;

vector<string> words;
map<char, int> dictionary;

bool cmp(string a, string b){
    for (unsigned i = 0; i < min(a.size(), b.size()); ++i){
        if (dictionary[a.at(i)] < dictionary[b.at(i)])
            return true;
        else if (dictionary[a.at(i)] > dictionary[b.at(i)])
            return false;
    }
    return a.size() == min(a.size(), b.size());
}

bool cmpR(string a, string b){
    return !cmp(a, b);
}

int main() {
    string dict;
    cin >> dict;
    for (unsigned i = 0; i < dict.size(); ++i)
        dictionary[dict.at(i)] = i;
    int n;
    cin >> n;
    for (int i = 0; i < n; ++i){
        string tmp;
        cin >> tmp;
        words.push_back(tmp);
    }
    int order;
    cin >> order;
    order == 1 ? sort(words.begin(), words.end(), cmp) : sort(words.begin(), words.end(), cmpR);
    for (const auto i : words)
        cout << i << endl;
    return 0;
}

```