## 课堂作业一

### Problem A. 课堂作业-9-1
```
时间限制 1000 ms
内存限制 64 MB
题目描述
楼梯有n阶，可以一步上一阶、两阶或三阶，问有多少种不同的走法
由于答案很大，mod(1e9+7)输出

输入数据
一个正整数n，代表楼梯的阶数，n<=1000000

输出数据
方案数

样例输入
3
样例输出
4
```


代码：
```

```
### Problem B. 全排列

```
时间限制 1000 ms
内存限制 128 MB
题目描述
输入两个自然数m,n 1< =n< =20，1< =m< =n!
输出n个数的第m种全排列。
如 ：
输入 3 1
输出 1 2 3

输入数据
在一行中输入 n m
输出数据
一个数列,既 n 个数的第 m 种排列
每两个数之间空 1 格
样例输入
3 2
样例输出
1 3 2
```


代码：
```
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

int main() {
	 int n;
	 long m;
	 cin >> n;
	 cin >> m;
	
	 long long *array = new long long[n + 1];
	 long long sum = 1;
	 array[0] = 1;
	
	 
	 for (int i = 1; i <= n; i++) {
		  sum *= i;
		  array[i] = sum;
	 } 
	 int a[20] = {0};
	 for (int i = 0; i < n; i++) {
	 	 a[i]=i + 1;
	 }
	 vector<int> nums(a, a + n);
	 
	 vector<int>nums2;
	 nums2.reserve(1000);
	 m--;
	 for (int i = 1; i <= n; i++) {
		  int index = m / array[n - i];
		  nums2.push_back(nums[index]);
		  auto it = remove(nums.begin(), nums.end(), nums[index]);
		  nums.erase(it, nums.end());
		  m = m % array[n - i];
	 }
	 auto it = nums2.begin();
	 for (int i = 0; i < n; i++)
	 {
		  cout << *it << " ";
		  it++;
	 }
	 cout << endl;
	 return 0;
}
```

## 研究生算法第一次课下作业
Problem A. 数的计数
```
时间限制 1000 ms
内存限制 128 MB
题目描述
　　我们要求找出具有下列性质数的个数(包含输入的自然数n):
　　先输入一个自然数n(n≤1000)，然后对此自然数按照如下方法进行处理
　　 l·不作任何处理:
　　2·茬它的左边加上一个自然数，但该自然数不能超过原数的一半;
　　3·加上数后，继续按此规则进行处理，直到不能再立生自然数为止。

输入数据
输出数据
样例输入
6
样例输出
6
```
代码：
```
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1005;
 
int n,f[maxn]={1},ans;
 
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		for(int j=0;j<=i/2;j++)
			f[i] += f[j];
	cout<<f[n]<<endl;
	return 0;
}
```
### Problem B. 均分纸牌
```
时间限制 1000 ms
内存限制 128 MB
题目描述
有 N 堆纸牌，编号分别为 1，2，…, N。每堆上有若干张，但纸牌总数必为 N 的倍数。可以在任一堆上取若于张纸牌，然后移动。
　　移牌规则为：在编号为 1 堆上取的纸牌，只能移到编号为 2 的堆上；在编号为 N 的堆上取的纸牌，只能移到编号为 N-1 的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。
　　现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。

　　例如 N=4，4 堆纸牌数分别为：
　　①　9　②　8　③　17　④　6
　　移动3次可达到目的：
　　从 ③ 取 4 张牌放到 ④ （9 8 13 10） -> 从 ③ 取 3 张牌放到 ②（9 11 10 10）-> 从 ② 取 1 张牌放到①（10 10 10 10）。

输入数据
N （ N  堆纸牌， 1 ≤ N ≤ 100 ）
A1 A2 … An （ N  堆纸牌，每堆纸牌初始数， l≤ Ai < 104 ）
输出数据
所有堆均达到相等时的最少移动次数。
样例输入
4
9 8 17 6
样例输出
3
```
代码：
```

#include <stdio.h>
int n;//纸牌堆数
int poke[100];
int count=0;
 
void move(int aver,int k)//移动纸牌，思路就是将每一堆排都变成均值排数
{
	int a;
	a=aver - poke[k];
	poke[k] += a;
	poke[k+1] -= a;
	count++;
	while(poke[k] == aver)
	k++;
	if(k < n)
	move(aver,k);
}
int main()
{
	int i,k;
	int aver;
	scanf("%d",&n);
	for(i=0;i < n;i++)
	{
		scanf("%d",&poke[i]);
		aver+=poke[i];
	}
	aver=aver/n;
	k=n;
	for(i=0;i < n;i++)
	{
		if(poke[i] != aver)
		{
			k=i;
			break;
		}
	}
	if(k < n)
	move(aver,k);
	printf("%d",count);
	return 0;
} 
```

### Problem C. Superprime
```
时间限制 1000 ms
内存限制 128 MB
题目描述
农民约翰的母牛总是生产出最好的肋骨。你能通过农民约翰和美国农业部标记在每根肋骨上的数字认出它们。
农民约翰确定他卖给买方的是真正的质数肋骨,是因为从右边开始切下肋骨,每次还剩下的肋骨上的数字都组成一个质数,举例来说:
7 3 3 1
全部肋骨上的数字 7331是质数;三根肋骨 733是质数;二根肋骨 73 是质数;当然,最后一根肋骨 7 也是质数。

7331 被叫做长度 4 的特殊质数。
写一个程序对给定的肋骨的数目 N (1< =N< =8),求出所有的特殊质数。数字1不被看作一个质数。

输入数据
单独的一行包含 N 。
输出数据
按顺序输出长度为  N  的特殊质数,每行一个。
并按大小顺序排列(从小到大).
样例输入
4
样例输出
2333
2339
2393
2399
2939
3119
3137
3733
3739
3793
3797
5939
7193
7331
7333
7393
```
代码：
```

#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <queue>
#include <vector>
using namespace std;
typedef long long ll;
vector<ll>  v[10];
#define MAX 1e9+7
ll yang(ll m)
{
    ll i;
    ll k;
    k=sqrt(m);
    for(i=2; i<=k; i++)
        if(m%i==0)
            break;
    if(i==k+1)
        return 1;
    else
        return 0;
}
int main()
{
    ll i,k,t,n,m=0,j,ans[10101]={0};
    cin>>n;
    v[1].push_back(2);
    v[1].push_back(3);
    v[1].push_back(5);
    v[1].push_back(7);
    for(k=1;k<=7;k++)
    {
        for(i=0;i<v[k].size();i++)
        {
            for(j=1;j<=9;j++)
            {
                t=v[k][i];
                t*=10;
                m=0;
                t+=j;
                m=yang(t);
                if(m==1)
                    v[k+1].push_back(t);
            }
        }
    }
    for(i=0;i<v[n].size();i++)
    {
        cout<<v[n][i]<<endl;
    }
    return 0;
}
```

## 研究生第二次算法作业

### Problem A. 最小数字倍数
```
时间限制 1000 ms
内存限制 128 MB
题目描述
　　写一个程序，对于给定的一个自然数N（0≤N≤4999），以及M个不同的十进制数字X1,X2...XM（M≥1 最多10个数字），找出一个由X1,X2..XM组成的整数P，使得P是N的严格的倍数，且要求P最小。

输入数据
第一行为一个整数 N 。第二行为一个整数 M 。此后的 M 行分别为 M 个数字 X1,X2..XM 。
输出数据
输出一个整数 P （占一行），保证有解。
样例输入
22
3
7
0
1
样例输出
110
```

代码：
```
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <queue>
#include <string>
#include <map>
#include <cstring>
#include <ctime>
#include <vector>
#define inf 1e9
#define ll long long
#define For(i,j,k) for(int i=j;i<=k;i++)
#define Dow(i,j,k) for(int i=k;i>=j;i--)
using namespace std;
int n,m,a[101],q[10001],num[10001],nxt[10001],vis[10001],l=1,r,ans,tot,ANS[10001];
int main()
{
    scanf("%d%d",&n,&m);
    For(i,1,m)  scanf("%d",&a[i]);
    sort(a+1,a+m+1);
    For(i,1,m)  if(a[i]&&!vis[a[i]%n])  q[++r]=a[i]%n,vis[a[i]%n]=1,num[r]=a[i],nxt[r]=-1;
    while(l<=r)
    {
        int t=q[l];
        if(t==0){ans=l;break;}
        For(i,1,m)
        {
            int tmp=(t*10+a[i])%n;
            if(!vis[tmp])
                q[++r]=tmp,num[r]=a[i],nxt[r]=l,vis[tmp]=1;
        }
        l++;
    }
    while(ans!=-1)
    {
        ANS[++tot]=num[ans];
        ans=nxt[ans];
    }
    Dow(i,1,tot)    printf("%d",ANS[i]);
}
     

```

### Problem B. Warcraft III 守望者的烦恼
```
时间限制 1000 ms
内存限制 128 MB
题目描述
头脑并不发达的warden最近在思考一个问题，她的闪烁技能是可以升级的，k级的闪烁技能最多可以向前移动k个监狱，一共有n个监狱要视察，她从入口进去，一路上有n个监狱，而且不会往回走，当然她并不用每个监狱都视察，但是她最后一定要到第n个监狱里去，因为监狱的出口在那里，但是她并不一定要到第1个监狱。
守望者warden现在想知道，她在拥有k级闪烁技能时视察n个监狱一共有多少种方案？

输入数据
第一行是闪烁技能的等级 k (1≤ k≤ 10)
第二行是监狱的个数 n (1≤ n≤ 231−1)
输出数据
由于方案个数会很多，所以输出它 mod 7777777后的结果就行了
样例输入
2
4
样例输出
5
样例说明
把监狱编号1 2 3 4,闪烁技能为2级，
一共有5种方案
→1→2→3→4
→2→3→4
→2→4
→1→3→4
→1→2→4

小提示：建议用int64，否则可能会溢出
```

代码：
```
#include<bits/stdc++.h>
using namespace std;
const int MOD=7777777;
int k,n;
struct node{
    long long a[12][12];
}c,ans;
inline node Mul1(node x,node y){
    node res;
    memset(res.a,0,sizeof(res.a));
    for(int i=1;i<=k;i++)
        for(int j=1;j<=1;j++)
            for(int l=1;l<=k;l++)
                res.a[i][j]=(res.a[i][j]+x.a[i][l]*y.a[l][j])%MOD;
    return res;
}
inline node Mul2(node x,node y){
    node res;
    memset(res.a,0,sizeof(res.a));
    for(int i=1;i<=k;i++)
        for(int j=1;j<=k;j++)
            for(int l=1;l<=k;l++)
                res.a[i][j]=(res.a[i][j]+x.a[i][l]*y.a[l][j])%MOD;
    return res;
}
int main(){
    cin>>k>>n;
    ans.a[k+1][1]=1;
    for(int i=1;i<=k;i++)
        for(int j=0;j<i;j++) ans.a[k-i+1][1]+=ans.a[k-j+1][1];
    for(int i=1;i<=k;i++) c.a[1][i]=1;
    for(int i=2;i<=k;i++) c.a[i][i-1]=1;
    if(n<=k) cout<<ans.a[k+1-n][1];
    else{
        n-=k;
        while(n){
            if(n&1) ans=Mul1(c,ans);
            c=Mul2(c,c);
            n>>=1;
        }
        cout<<ans.a[1][1];
    }
}
```


### Problem C. 新年趣事之玩具
```
时间限制 1000 ms
内存限制 128 MB
题目描述
　　今年春节，xiaomengxian回到了邵阳过年。刚准备进门时，突然发现院子里有个小孩在摆弄什么东西。走进一看，原来他在玩一种智力玩具，叫做“汉诺塔”。“汉诺塔”是这样一种玩具：有三个柱子，分别编号：#1，#2，#3。初始时，有N个直径不同的盘子放在第一根柱子上，且越底下的盘子直径越大。游戏的目的是把所有的盘子转移到第二根柱子上。约束条件是：任何时候都只能把小盘子放在大盘子上。
　　由于盘子数目比较多，小孩玩了很久都没有完成任务。于是，xiaomengxian走上前去，打开随身携带的笔记本电脑，运行了一个很久以前编写的程序。它的主要过程大致是这样的：
　　procedure hanoi(n:integer;from,to,temp:integer);
　　begin
　　 if n> 0 then
　　 begin
　　　　 hanoi(n-1,from,temp,to);
　　　　 writeln(n,from,to);
　　　　 hanoi(n-1,temp,to,from)
　　 end
　　end;
　　有了xiaomengxian的帮助，小孩很快就完成了任务。他在感谢xiaomengxian的同时，又问了一个问题，想考考xiaomengxian。这个问题就是，给出一个中间状态，能否很快的说出这是第几次移动后的状态？
为了描述方便，对于每一个中间状态，我们定义序列D。其中，Di表示第i小的盘子所在的柱子编号。显然，Di=1，2，3。
　　下面是N=3的例子：
　　

输入数据
　　第一行为一个整数 N （ 1≤ N≤ 31 ）
　　第二行为 N 个整数，用空格分开，表示序列 D 。
输出数据
　　一个整数，表示该状态是第几次移动后的结果。如果该状态不是由上述代码产生的中间状态，则输出“-1”。
样例输入
3
3 3 1
样例输出
3
```

代码：
```
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>

using namespace std;

int n,step=0;
int a[50];
bool ok=1;

void mov(int n,int from,int to,int temp)
{   

    if(!ok || n<=0) return;
    if(a[n]==from)
    {
        mov(n-1,from,temp,to);
    }
    else if(a[n]==to)
    {
        step+=pow(2,n-1);
        mov(n-1,temp,to,from);
    }
    else if(a[n]==temp)
    {   
        ok=0;
        return;
    }
    //cout<<n<<" "<<from<<" "<<to<<endl;
}

int main()
{
    ios::sync_with_stdio(0);
    cin>>n;
    for(int i=1;i<=n;i++)
      cin>>a[i];
    mov(n,1,2,3);
    if(ok)
      cout<<step;
    else
      cout<<"-1"; 
    return 0;
}
```

### Problem D. 逆序对加强版
```
时间限制 1000 ms
内存限制 128 MB
题目描述
　　SORT公司是一个专门为人们提供排序服务的公司，该公司的宗旨是：“顺序是最美丽的”。他们的工作是通过一系列移动，将某些物品按顺序摆好。他们的服务是通过工作量来计算的，即移动东西的次数。所以，在工作前必须先考察工作量，以便向用户提出收费数目。
　　用户并不需要知道精确的移动次数，实质上，大多数人都是凭感觉来认定这一列物品的混乱程度，根据SORT公司的经验，人们一般是根据“逆序对”的数目多少来称呼这一序列的混乱程度。假设我们将序列中第i件物品的参数定义为Ai，那么排序就是指将Ai，…，An从小到大排序。若i< j且Ai> Aj，则< i,j> 就为一个“逆序对”。　　
　　例如，数组（3，1，4，5，2）的“逆序对”有< 3，1> ，< 3，2> ，< 4，2> ，< 5，2> ，共4个

　　SORT公司请你写一个程序，在尽量短的时间内，统计出“逆序对”的数目。
[输入]n，A1，…，An，1< n< 1000000，Ai为小于1000000的正整数,请注意数据大小，模拟绝对会爆！
[输出]数列A1，…，An的“逆序对”数目，即“逆序数”
[输入输出样例]
　　输入：5 3 1 4 5 2
　　输出：4
```

代码：
```
#include<cstdio>
using namespace std;
int data[1000003];
int fu[1000003];
long long res = 0;
void qsort(int l, int r)
{
    if(l == r) return;
    int mid = l + (r - l) / 2;
    qsort(l, mid);
    qsort(mid + 1, r);
    int p1 = l, p2 = mid + 1;
    int p3 = l;
    while(p1 <= mid || p2 <= r)
    {
        if(p1 <= mid && p2 <= r)
        {
            if(data[p1] <= data[p2]) fu[p3++] = data[p1++];
            else 
            {
                res += (mid - p1 + 1);
                fu[p3++] = data[p2++];
            }
        }
        else if(p1 <= mid && p2 > r) fu[p3++] = data[p1++];
        else fu[p3++] = data[p2++];
    }
    for(int i = l; i <= r; i++)
    data[i] = fu[i]; 
}
int main()
{
    int n;
    scanf("%d", &n);
    for(int i = 1; i <= n; i++)
        scanf("%d", &data[i]);
    qsort(1, n);
    printf("%lld", res);
    return 0;
}
```

### Problem E. 课堂作业-6-3
```
时间限制 1000 ms
内存限制 64 MB
题目描述
李老师的lucky number 是3，5和7，他爱屋及乌，还把所有质因数只有3，5，7的数字认定为lucky number，比如9, 15, 21, 25等等。请聪明的你帮忙算一算小于等于x的lucky number有多少个？

输入数据
一个正整数x，3=<x<=1000000000000

输出数据
小于等于x的lucky number的个数。

样例输入
49
样例输出
11
样例说明
int存不下
```
代码：
```
#include<stdio.h>
#include<math.h>
#include<iomanip>
#include "stdlib.h"
#include <iostream>
using namespace std;
long rooting(long x, int a);
int main(){
    long x;
    long count = 0;
    cin >> x;

    long three_times =rooting(x,3);
    long five_times = rooting(x, 5);
    long seven_times = rooting(x,7);

    //count = three_times + five_times + seven_times;

    for (long i = 0; i <three_times + 1; i++)
        for (long j = 0; j < five_times + 1; j++)
            for (long k = 0; k < seven_times + 1; k++){
                if ((pow(3, i)* pow(5, j) * pow(7, k) <= x) && (i + j + k)>0) {
                    count = count + 1;
                    //cout << "i:" << i << "  j:" << j << "  k:" << k << endl;
                }
            }
    cout << count << endl;
    return 0;
}

long rooting(long x, int a){
    int three_m = x % a;
    x = x - three_m;
    long times = 0;
    while (x > 1){
        x = x / a;
        times = times + 1;
    }
    return times;
}
```

### Problem F. 课堂作业-7-4
```
时间限制 5000 ms
内存限制 64 MB
题目描述
对于一个长为n的数组A0,A1,A2......An-1，定义这个数组的得分为(A0 xor A1)+(A1 xor A2)+(A2 xor A3）+......+(An-2 xor An-1) ，即相邻两项的异或值的加和，比如数组1 1 2 2的得分为(1 xor 1) + (1 xor 2) + (2 xor 2) = 0+3+0 = 3
现在你可以重新排列这个数组，问最大得分是多少

输入数据
第一行为数组长度n，1=<n<=10 第二行为n个数，代表这个数组，每个数不超过1e9

输出数据
最大的得分是多少

样例输入
4
1 1 2 2
样例输出
9
样例说明
可以用STL函数next_permutation
```

代码：
```

#include<bits/stdc++.h>
using namespace std;

int main(int argc, char** argv) {
	 int n;
	 cin>>n;
	 long long  a[10];
	 for(int i=0;i<n;i++){
	  	cin>>a[i];
	 }
	 long long max=0;
	 sort(a,a+n);
	 do{
	 // cout<<a[0]<<a[1]<<a[2]<<a[3]<<endl;
		  long long tmp=0;
			  for(int i=0;i<n-1;i++){
			    tmp+=a[i]^a[i+1];
			  }
		  if(max<tmp){
		 	  max=tmp;
		  }
	 }while(next_permutation(a,a+n));
	 cout<<max<<endl; 
	 return 0;
}
```

## 研究生第三次算法作业

### Problem A. 伊甸园日历游戏
```
时间限制 1000 ms
内存限制 128 MB
题目描述
Adam和Eve玩一个游戏，他们先从1900.1.1到2001.11.4这个日期之间随意抽取一个日期出来。然后他们轮流对这个日期进行操作：

1 ： 把日期的天数加1，例如1900.1.1变到1900.1.2

2 ： 把月份加1，例如：1900.1.1变到1900.2.1

其中如果天数超过应有天数则日期变更到下个月的第1天。月份超过12则变到下一年的1月。而且进行操作二的时候，如果有这样的日期：1900.1.31，则变成了1900.2.31，这样的操作是非法的，我们不允许这样做。而且所有的操作均要考虑历法和闰年的规定。

谁先将日期变到2001.11.4谁就赢了。

每次游戏都是Adam先操作，问他有没有必胜策略？

输入数据
一个测试点。多组数据。
第一行为数据组数。
接下来一行 X Y Z 表示 X 年 Y 月 Z 日
输出数据
输出“YES”or“NO”表示亚当是否有必胜策略。
样例输入
3
2001 11 3
2001 11 2
2001 10 3
样例输出
YES
NO
NO
```
代码：
```
#include<bits/stdc++.h>
using namespace std;
int main(){
	int T;
	int y,m,d;
	cin>>T;
	while(T--){
		cin>>y>>m>>d;
		if((m==9&&d==30)||(m==11&&d==30)||(m+d)%2==0){
			cout<<"YES"<<endl;
		}else{
			cout<<"NO"<<endl;
		}
	}
	return 0;
}
```

### Problem B. 吃糖果游戏
```
题目描述
　　Matrix67和Shadow正在做一个小游戏。
　　桌子上放着两堆糖果，Matrix67和Shadow轮流对这些糖果进行操作。在每一次操作中，操作者需要吃掉其中一堆糖果，并且把另一堆糖果分成两堆（可以不相等）留给对方操作。游戏如此进行下去，糖果数会越来越少，最后必将出现这样一种情况：某人吃掉一堆糖果后发现另一堆里只剩一块糖果不能再分了。游戏规定此时该操作者吃掉最后这一块糖果从而取胜。
　　这个游戏是不公平的。对于任意一种初始状态，总有一方有必胜策略。所谓有必胜策略是指，无论对方如何操作，自己总有办法取胜。
　　Matrix67和Shadow将进行10次游戏，每一次游戏中总是Matrix67先进行操作。Matrix67想知道每一次游戏中谁有必胜策略。

输入数据
　　输入数据一共 10 行，每行有两个用空格隔开的正整数，表示一次游戏开始时桌子上两堆糖果分别有多少个。
　　对于 50 的数据，这些正整数均不超过100；
　　对于 70 的数据，这些正整数均不超过 10 000 ；
　　对于100%的数据，这些正整数均不超过 10 000 位。
输出数据
　　输出十行字符串。这些字符串只能是“Matrix67”或“Shadow”，它们表示对应的十行输入数据中有必胜策略的一方。
　　请注意大小写。
样例输入
1 1
1 2
1 3
1 4
1 5
2 1
2 2
2 3
2 4
2 5
样例输出
Matrix67
Matrix67
Matrix67
Matrix67
Matrix67
Matrix67
Shadow
Shadow
Matrix67
Matrix67
```
代码：
```
#include <iostream>
#include <cstdio>
using namespace std;
int main()
{
    int i=1;
    string a,b;
    char c,d;
    while(i<=10)
    {
        ++i;
        cin>>a;
        if(a=="-1")
        break;
        cin>>b;
        c=a[a.length()-1];
        d=b[b.length()-1];
        if((c=='2'||c=='3'||c=='7'||c=='8')&&(d=='2'||d=='3'||d=='7'||d=='8'))
        cout<<"Shadow\n";
        else
        cout<<"Matrix67\n";
    }
    return 0;
}
```

### Problem C. 欧几里德的游戏
```
题目描述
　　欧几里德的两个后代Stan和Ollie正在玩一种数字游戏，这个游戏是他们的祖先欧几里德发明的。给定两个正整数M和N，从Stan开始，从其中较大的一个数，减去较小的数的正整数倍，当然，得到的数不能小于0。然后是Ollie，对刚才得到的数，和M，N中较小的那个数，再进行同样的操作……直到一个人得到了0，他就取得了胜利。下面是他们用(25，7)两个数游戏的过程：
Start：25 7
Stan：11 7
Ollie：4 7
Stan：4 3
Ollie：1 3
Stan：1 0
Stan赢得了游戏的胜利。
现在，假设他们完美地操作，谁会取得胜利呢？

输入数据
第一行为测试数据的组数 C 。下面有 C 行，每行为一组数据，包含两个正整数 M, N 。（ M, N 不超过长整型。）
输出数据
对每组输入数据输出一行，如果Stan胜利，则输出“Stan wins”；否则输出“Ollie wins”
样例输入
2
25 7
24 15

样例输出
Stan wins
Ollie wins
```

代码：
```
#include<iostream>
using namespace std;
long long a,b,c;
int ans;
void dfs(int x,int y,int s)
{
    if(x>y)swap(x,y);
    if(y%x==0||y/x>1){ans=s;return;}
    dfs(x,y-x,(s+1)%2);
}
int main()
{
    cin>>c;
    while(c--)
    {
        ans=-1;
        cin>>a>>b,dfs(a,b,0);
        if(ans==0)cout<<"Stan wins"<<endl;
        if(ans==1)cout<<"Ollie wins"<<endl;
    }
}
```

### Problem D. 盒子与球
```
题目描述
现有r个互不相同的盒子和n个互不相同的球，要将这n个球放入r个盒子中，且不允许有空盒子。问有多少种方法？
例如：有2个不同的盒子（分别编为1号和2号）和3个不同的球（分别编为1、2、3号），则有6种不同的方法：
1号盒子　　1号球 1、2号球 1、3号球　　2号球 2、3号球　　3号球
2号盒子 2、3号球　　3号球　　2号球 1、3号球　　1号球 1、2号球

输入数据
两个整数， n 和 r ，中间用空格分隔。（0≤n, r≤10）
输出数据
N 臢 圠 �N N∗etep�O 輯罻  (�etW 媰  V 鬛 �0  坔 y: nN∗t e> Qe rN∗v 襕 Pv 別筶�

样例输入
3 2
样例输出
6
样例说明
第二类Stirling数。
```

代码：
```
#include<bits/stdc++.h>
using namespace std;
#define l long long
l al[11][11],n,r;
l jc(l a){
    l ans=1;
    for(int i=1;i<=a;i++)
        ans*=i;
    return ans;
}
int main(){
    cin>>n>>r;
    for(int i=0;i<=10;i++)
        al[i][i]=1;
    for(int i=1;i<=10;i++)
        al[i][0]=0;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=r;j++)
            al[i][j]=al[i-1][j-1]+al[i-1][j]*j;
    cout<<al[n][r]*jc(r);
    return 0;
}
```

### Problem E. Easy Selection
```
题目描述
这个游戏是这样的，wind先写下一排数。既然是一排，当然有首尾咯。
wind和小杉(lolanv)每次只能从这排数的头或尾取一个数。
最后谁取的数的和多，谁就赢了。如果两人的和一样多，先取者胜。

有天swgr看到他们俩在玩这个游戏，很好奇。
他想知道，在两人总是做出最优决策的情况下（两个人的智商都是很高的……），
谁能取得最终的胜利呢？

输入数据
第一行为一个数 k (k≤ 10) ，表示有 k 组测试数据。
以下 k 组测试数据。
每组测试数据中，第一行仅有一个偶数 n (0< n< 105)
第二行也仅有一个数， 0 表示wind先取数， 1 表示小杉  (lolanv) 先取数
第三行有 n 个数，是wind给出的一排数。这 n 个数的绝对值均不超过1e6
输出数据
对每组测试数据输出一行
表示在两人总是做出最优决策的情况下，
最终的胜利者的名字，即 " wind"  或 " lolanv"  （引号不输出）。
样例输入
2
2
1
1 3
2
0
1 3

样例输出
lolanv
wind
```
代码:
```
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
using namespace std;
//先取的人可以比较所有奇数位置数之和与所有偶数位置之和,哪个大就一直取相应的位置上的数....注意N为整数
//
//比如,6 1000 564 48 400 2
//
//奇数位置和为6+564+400=970 偶数位置和为1000+48+2=1050>970
//
//故先去的人可以先取2 后取的必定在奇数位置上取数(他只能取奇数位置的了)
//
//PS:先取的不一定是当前最优.......
int main()
{
    int k,q;
    scanf("%d",&k);
    for(q=1;q<=k;q++)
    {
        int n,who;
        int a;
        scanf("%d\n%d\n",&n,&who);
        for(int i=1;i<=n;i++)
        {
            scanf("%d",&a);
        }
        if(who==0)
            printf("wind\n");
        else
            printf("lolanv\n");
    }
    return 0;
}
```

## 课堂练习（二）
### Problem A. 肥猫的游戏

```
题目描述
　　野猫与胖子，合起来简称肥猫，是一个班的同学，他们也都是数学高手，所以经常在一起讨论数学问题也就不足为奇了。一次，野猫遇到了一道有趣的几何游戏题目，便拿给胖子看。游戏要求在一个有n个顶点凸多边形上进行，这个凸多边形的n-3条对角线将多边形分成n-2个三角形，这n-3条对角线在多边形的顶点相交。三角形中的一个被染成黑色，其余是白色。双方轮流进行游戏，当轮到一方时，他必须沿着画好的对角线，从多边形上切下一个三角形。切下黑色三角形的一方获胜。胖子一看觉得确实很有趣，不如就一起玩玩吧。假设游戏由野猫先开始，那么野猫是否有必胜的策略呢？请写一个程序帮助野猫算一算。

输入数据
第一行为一个整数 n (4≤ n< 5× 104) ，表示多边形的顶点数，多边形的顶点由 0 至 n－1 顺时针标号。接着的 n−2 行描述组成多边形的三角形。第 i+1 行  (1≤ i≤ n−2) 有三个空格分隔的非负整数a、b、c，它们是第 i 个三角形的顶点编号。第一个给出的三角形是黑色的。
输出数据
只有一行，倘若野猫有必胜策略，输出JMcat Win；否则，输出 PZ Win 。（注意大小写和空格）
样例输入
6
0 1 2
2 4 3
4 2 0
0 5 4
样例输出
JMcat Win
样例说明
如果连接一个多边形中任意两点的线段都完全包含于这个多边形，则称这个多边形为凸多边形。
```
代码

```
#include <iostream>
#include <cstdio>
#include <queue>
#include <algorithm>
#include <cmath>
#include <cstring>
#define inf 2147483647
#define N 1000010
#define p(a) putchar(a)
#define For(i,a,b) for(int i=a;i<=b;++i)
//by war
//2019.8.9
using namespace std;
int n;
int a[10];
int flag;
void in(int &x){
    int y=1;char c=getchar();x=0;
    while(c<'0'||c>'9'){if(c=='-')y=-1;c=getchar();}
    while(c<='9'&&c>='0'){ x=(x<<1)+(x<<3)+c-'0';c=getchar();}
    x*=y;
}
void o(int x){
    if(x<0){p('-');x=-x;}
    if(x>9)o(x/10);
    p(x%10+'0');
}

signed main(){
    in(n);
    in(a[1]);in(a[2]);in(a[3]);
    For(i,1,n-3)
        in(a[4]),in(a[5]),in(a[6]);
    sort(a+1,a+3+1);
    if(a[3]-a[2]==1&&a[2]-a[1]==1){
        puts("JMcat Win");
    }    
    else
        if((a[3]-a[2]==1&&a[2]-a[1]!=1) || (a[3]-a[2]!=1&&a[2]-a[1]==1) || (a[1]+a[3]==n-1 && (a[2]!=1||a[2]!=n-2))){
            if(n&1)
                puts("PZ Win");
            else
                puts("JMcat Win");
        }
    else
        if(a[3]-a[2]!=1 && a[2]-a[1]!=1){
            if(n&1)
                puts("PZ Win");
            else
                puts("JMcat Win");
        }
    return 0;
}
```

### Problem B. 课间十分钟
```
题目描述
两人都是数学爱好者，便发明了一个游戏。
在游戏开始前，他们先约定一个正整数n，同时令m=1。游戏过程中，每个人都可以将m的值扩大2到9中的任意倍数。第一个使m≥n的人就是最后的赢家。
181818181818和ZBT都十分聪明，并且游戏过程中都使用最佳的策略，问谁会是最后的赢家。（181818181818总是第一个先玩）

输入：一个正整数n（1≤n≤2^32-1）

输出：在使用最佳的策略的情况下，如果181818181818必胜，则输出“181818181818”。如果ZBT必胜，则输出“ZBT”。

输入数据
输出数据
样例输入
9
样例输出
181818181818
```

方法：
```
if __name__ == '__main__':
    n = int(input())
    m = 1
    while m < n:
        m = m * 18
    if n == 1:
        print("181818181818")
    elif n <= m / 2:
        print("181818181818")
    else:
        print("ZBT")
```


## 研究生第四次算法作业

### Problem A. 水王争霸
```
题目描述
众所周知，IOIForum有很多水王，他们的发贴数是如此之多，以至于必须要用高精度数才能保存。
为了迎接国庆，IOIForum决定举行一次水王争霸赛，比赛的规则是将这些水王截止到2003年9月30日23时59分59秒这一刻所发的总贴数从大到小进行排序。每个水王当然都想取得尽量靠前的名次，所以他们竭尽全力，不择手段地进行灌水。
终于，激动人心的一刻到来了，2003年10月1日0时0分0秒，你作为裁判得到了每个水王的发贴数，现在，你的任务是公正地把这些水王按照发贴数从大到小进行排序。

输入数据
输入的第一行是一个 1 到1000的整数 N ，表示总共有 N 位水王参加了争霸赛。
以下依次给出每位水王的描述，一位水王的描述占据两行，第一行为一个仅由字母和数字组成的长度不超过 20 的字符串，代表这个水王的 ID ，第二行一个高精度的整数(非负数)，代表这个水王的发贴数。注意，这个整数的首位没有不必要的 0 。
考虑到IOIForum的数据库是有限的，所有水王发贴数的总长度（注意，是总长度而不是总和）不会超�10^{4}。
除了子母、数字和必要的换行，输入中不会出现空格等字符。
输出数据
依次输出按照发贴数从大到小排好序的各位水王的 ID ，每个 ID 占据单独的一行。不能有任何多余的字符。若几个 ID 的发贴数相同，则按照 ID 的字典顺序先后排列。
样例输入
6
lowai
1534534124561243453
zhouyuan
23453265344
Maolaoda
23442353452342
BuTaoCaiGuai
7568784573464
ArthurKing
97534892734723947
hyyylr
623893451
样例输出
lowai
ArthurKing
Maolaoda
BuTaoCaiGuai
zhouyuan
hyyylr
```

代码：
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
struct node
{
    char name[25];
    char score[1005];
}king[10005];
bool cmp(node x,node y)
{
    if(strlen(x.score)<strlen(y.score))
        return 0;
    else if(strlen(x.score)==strlen(y.score))
    {
        if(strcmp(x.score,y.score)<0)
            return 0;
        if(strcmp(x.score,y.score)==0)
        {
            return strcmp(x.name,y.name)<0;
            return 1;
        }
    }
}
int main()
{
    int n;
    scanf("%d",&n);
    int i;
    for(i=0;i<n;i++)
    {
        scanf("%s%s",king[i].name,king[i].score);
    }
    sort(king,king+n,cmp);
    for(i=0;i<n;i++)
    {
        printf("%s\n",king[i].name);
    }
    return 0;
}
```

### Problem B. 佳佳的魔法照片
```
题目描述
一共有n个人（以1--n编号）向佳佳要照片，而佳佳只能把照片给其中的k个人。佳佳按照与他们的关系好坏的程度给每个人赋予了一个初始权值W[i]。然后将初始权值从大到小进行排序，每人就有了一个序号D[i]（取值同样是1--n）。按照这个序号对10取模的值将这些人分为10类。也就是说定义每个人的类别序号C[i]的值为(D[i]-1) mod 10 +1，显然类别序号的取值为1--10。第i类的人将会额外得到E[i]的权值。你需要做的就是求出加上额外权值以后，最终的权值最大的k个人，并输出他们的编号。在排序中，如果两人的W[i]相同，编号小的优先。

输入数据
第一行输出用空格隔开的两个整数，分别是 n 和 k 。
第二行给出了 10 个正整数，分别是 E[1] 到 E[10] 。
第三行给出了 n 个正整数，第 i 个数表示编号为 i 的人的权值 W[i] 。
输出数据
只需输出一行用空格隔开的 k 个整数，分别表示最终的 W[i] 从高到低的人的编号。
样例输入
10 10
1 2 3 4 5 6 7 8 9 10
2 4 6 8 10 12 14 16 18 20
样例输出
10 9 8 7 6 5 4 3 2 1
样例说明
对于50%的数据，n< =200；
对于100%的数据，n< =50 000，k< =2000，给出的所有正整数都不超过32767。
```

代码：
```
#include<iostream>
#include<algorithm>
using namespace std;
struct data
{
       int num,w,d;
       }a[5000001];
inline bool cp(data a,data b)
{
    return (a.w==b.w)?a.num<b.num:a.w>b.w;
}
int main()
{
	int n,k,e[11];
	cin>>n>>k;
	for(int i=1;i<=10;i++)
	   cin>>e[i];
	for(int i=1;i<=n;i++)
	{
            a[i].num=i;
            cin>>a[i].w;
            }
    sort(a+1,a+n+1,cp);
    for(int i=1;i<=n;i++)
            a[i].w+=e[(i-1)%10+1];
    sort(a+1,a+n+1,cp);
    for(int i=1;i<=k;i++) 
    {
       cout<<a[i].num<<' ';
       }   
    return 0;
}
```


### Problem C. 大整数
```
题目描述
一个k(1< =k< =80)位的十进制正整数N,就是所谓的大整数.
请你设计程序,对于给出的某一个大整数N,找到满足p^3+p^2+3p< =n的p的最大值.

输入数据
输入数据只有一行，是一个 K 位的大整数 N ，行首行未无多余空格
输出数据
输出第一行为你所找到的 P 最大值，行首行末别乱加东西
样例输入
1000000000000001000000000000003000000000000001
样例输出
1000000000000000
```
代码(代码不好)
```
def main():
    number = int(input())
    left = 0
    right = number
    while left < right:
        mid = left + (right - left) // 2
        if mid == left:
            break
        if mid * mid * mid + mid * mid + mid * 3 <= number:
            left = mid
        else:
            right = mid
    print(left)

if __name__ == '__main__':
    main()
```

### Problem D. 奖学金
```
题目描述
　　某小学最近得到了一笔赞助，打算拿出其中一部分为学习成绩优秀的前5名学生发奖学金。期末，每个学生都有3门课的成绩：语文、数学、英语。先按总分从高到低排序，如果两个同学总分相同，再按语文成绩从高到低排序，如果两个同学总分和语文成绩都相同，那么规定学号小的同学排在前面，这样，每个学生的排序是唯一确定的。
　　任务：先根据输入的3门课的成绩计算总分，然后按上述规则排序，最后按排名顺序输出前5名学生的学号和总分。注意，在前5名同学中，每个人的奖学金都不相同，因此，你必须严格按上述规则排序。例如，在某个正确答案中，如果前两行的输出数据(每行输出两个数：学号、总分)是：
　　7 279
　　5 279
　　这两行数据的含义是：总分最高的两个同学的学号依次是7号、5号。这两名同学的总分都是279(总分等于输入的语文、数学、英语三科成绩之和)，但学号为7的学生语文成绩更高一些。如果你的前两名的输出数据是：
　　5 279
　　7 279
　　则按输出错误处理，不能得分。

输入数据
　　输入包含 n+1 行：
　　第 l 行为一个正整数 n ，表示该校参加评选的学生人数。
　　第 2 到年 n+l 行，每行有 3 个用空格隔开的数字，每个数字都在 0 到100之间。第 j 行的 3 个数字依次表示学号为 j−1 的学生的语文、数学、英语的成绩。每个学生的学号按照输入顺序编号为 1～n ( 恰好是输入数据的行号减 1) 。
　　所给的数据都是正确的，不必检验。
输出数据
　　输出共有 5 行，每行是两个用空格隔开的正整数，依次表示前 5 名学生的学号和总分。
样例输入
Sample 1:
6
90 67 80
87 66 91
78 89 91
88 99 77
67 89 64
78 89 98

Sample 2:
8
80 89 89
88 98 78
90 67 80
87 66 91
78 89 91
88 99 77
67 89 64
78 89 98
样例输出
Sample 1:
6 265
4 264
3 258
2 244
1 237

Sample 2:
8 265
2 264
6 264
1 258
5 258
样例说明
50%的数据满足：各学生的总成绩各不相同
100%的数据满足：6< =n< =300
```
代码:
```
#include<iostream>
#include<algorithm>
using namespace std;
struct stu
{
int xh,ch,math,eng,sum;
};
bool cmp(stu x,stu y)
{
if(x.sum>y.sum) return true;
else if(x.sum==y.sum&&x.ch>y.ch) return true;
else if(x.sum==y.sum&&x.ch==y.ch&&x.xh<y.xh) return true;
else return false;
}
int main()
{
int n;
cin>>n;
stu student[301];
for(int i=0;i<n;i++)
{
cin>>student[i].ch>>student[i].math>>student[i].eng;
student[i].sum=student[i].ch+student[i].math+student[i].eng;
student[i].xh=i+1;
}
sort(student,student+n,cmp);
for(int i=0;i<5;i++)
{
cout<<student[i].xh<<" "<<student[i].sum<<endl;
}
return 0;
}
```

### Problem E. 遭遇战
```
题目描述
今天，他们在打一张叫DUSTII的地图，万恶的恐怖分子要炸掉藏在A区的SQC论坛服务器！我们SQC的人誓死不屈，即将于恐怖分子展开激战，准备让一个人守着A区，这样恐怖分子就不能炸掉服务器了。（一个人就能守住??这人是机械战警还是霹雳游侠？）
但是问题随之出现了，由于DustII中风景秀丽，而且不收门票，所以n名反恐精英们很喜欢在这里散步，喝茶。他们不愿意去单独守在荒无人烟的A区，在指挥官的一再命令下，他们终于妥协了，但是他们每个人都要求能继续旅游，于是给出了自己的空闲时间，而且你强大的情报系统告诉了你恐怖份子计划的进攻时间（从s时刻到e时刻）。
当然，精明的SQC成员不会为你免费服务，他们还要收取一定的佣金（注意，只要你聘用这个队员，不论他的执勤时间多少，都要付所有被要求的佣金）。身为指挥官的你，看看口袋里不多的资金（上头真抠！），需要安排一个计划，雇佣一些队员，让他们在保证在进攻时间里每时每刻都有人员执勤，花费的最少资金。

输入数据
第一行是三个整数n(1≤n�10^{4})，s和e（1≤s≤e�9\times 10^{4}）。
接下来n行，描述每个反恐队员的信息：空闲的时间si, ei（1≤si≤ei�9\times 10^{4}）和佣金ci（1≤ci�3\times 10^{5}）。
输出数据
一个整数，最少需支付的佣金，如果无解，输出“-1”。
样例输入
3 1 5
1 3 3
4 5 2
1 1 1
样例输出
5
样例说明
敌人从1时刻到4时刻要来进攻，一共有3名反恐队员。第1名从1时刻到3时刻有空，要3元钱（买糖都不够??）。以此类推。
一共要付5元钱，选用第1名和第2名。
```
代码：
```
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<queue>
#include<vector>
using namespace std;
const int maxn=10010;
const long long inf=1000000000000LL;
struct node{
    int l;
    int r;
    long long c;
    bool operator > (const node &a)const
    {
	return c>a.c;
    }
}a[maxn];
int n,s,e,m;
long long t[300010*4],val;
priority_queue<node, vector<node>, greater<node> > q;
bool cmp(node a,node b){
    if(a.l==b.l)
	return a.r<b.r;
    return a.l<b.l;
}
int main(){
    while(scanf("%d%d%d",&n,&s,&e)!=EOF){
	for(int i=0;i<n;i++)
	    scanf("%d%d%lld",&a[i].l,&a[i].r,&a[i].c);
	sort(a,a+n,cmp);
	if(a[0].l>s)
	{
	    printf("-1\n");
	    continue;
	}
	q.push(a[0]);
	long long ans=inf;
	for(int i=1;i<n;i++)
	{
	    while(!q.empty())
	    {
		node ita=q.top();
		if(ita.r>=e)
		{
		    ans=ita.c;
		    break;
		}
		if(ita.r>=a[i].l-1)
		{
		    if(ita.l<a[i].l)
			a[i].c+=ita.c;
		    q.push(a[i]);
		    break;
		}
		else
		    q.pop();
	    }
	}
	while(!q.empty())
	{
	    node ita=q.top();
	    q.pop();
	    if(ans==inf&&ita.r>=e)
		ans=ita.c;
	}
	if(ans==inf)
	    printf("-1\n");
	else
	    printf("%lld\n",ans);
    }
    return 0;
}
```

###
```
题目描述
笨笨有一些单词，他想要把这些单词按一定顺序排序。

现在笨笨有N(N< =1000)个单词，他想要你按笨笨的字典序把这些单词顺序或逆序排列好来。

输入笨笨的字典序以及他所要排序的单词和他所要的排序方式（顺序或逆序，顺序用1表示，逆序用0表示）。

请你把排好的单词输出,每个单词长度不超过255个字符,中间没有空格。

输入数据
第一行，一个长度为 26 的字母不重复的字符串，表示笨笨的字典序（ 26 个字母全齐）。
第二行一个数 N 。
接下来 N 行，每行一个单词。
最后一行是笨笨所想要的排序方式。
输出数据
输出共 N 行，表示排好序的单词。输出每行一个单词。
样例输入
abcdefghijklmnopqrstuvwxyz
2
big
small
1
样例输出
big
small
样例说明
是笨笨的字典序，不是一般的字典序哦。
输入输出中的字母均为小写字母。
注：顺序逆序就是说把它们按一定的顺序排列好，而不是要你把单词反过来。
如（按字典序）：
顺序为：
aa
ba
ca
逆序为
ca
ba
aa
```
代码：
```
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>

using namespace std;

vector<string> words;
map<char, int> dictionary;

bool cmp(string a, string b){
    for (unsigned i = 0; i < min(a.size(), b.size()); ++i){
        if (dictionary[a.at(i)] < dictionary[b.at(i)])
            return true;
        else if (dictionary[a.at(i)] > dictionary[b.at(i)])
            return false;
    }
    return a.size() == min(a.size(), b.size());
}

bool cmpR(string a, string b){
    return !cmp(a, b);
}

int main() {
    string dict;
    cin >> dict;
    for (unsigned i = 0; i < dict.size(); ++i)
        dictionary[dict.at(i)] = i;
    int n;
    cin >> n;
    for (int i = 0; i < n; ++i){
        string tmp;
        cin >> tmp;
        words.push_back(tmp);
    }
    int order;
    cin >> order;
    order == 1 ? sort(words.begin(), words.end(), cmp) : sort(words.begin(), words.end(), cmpR);
    for (const auto i : words)
        cout << i << endl;
    return 0;
}

```

## 研究生第五次算法作业
### Problem  A - 合唱队形
```
题目描述
　　N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学排成合唱队形。
　　合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1，2…，K，他们的身高分别为T1，T2，…，TK， 则他们的身高满足T1< ...< Ti> Ti+1> …> TK(1< =i< =K)。
　　你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。

输入数据
输入的第一行是一个整数 N (2≤ N≤ 100) ，表示同学的总数。第一行有 n 个整数，用空格分隔，第 i 个整数 Ti (130≤ Ti≤ 230) 是第 i 位同学的身高(厘米)。
输出数据
输出包括一行，这一行只包含一个整数，就是最少需要几位同学出列。
样例输入
8
186 186 150 200 160 130 197 220
样例输出
4
```
代码
```
#include<iostream>
#include<cstdio>
#include<cctype>
#include<cstring>
using namespace std;
template<typename T>
inline void readInteger(T& u){
    char x;
    while(!isdigit((x = getchar())));
    for(u = x - '0';isdigit((x = getchar()));u = ((u << 3) + (u << 1) + x - '0'));
    ungetc(x, stdin);
}
int n;
int *l,*r;
int *h;
void init(){
    readInteger(n);
    h = new int[(const int)(n + 1)];
    l = new int[(const int)(n + 1)];
    r = new int[(const int)(n + 1)];
    for(int i = 1;i <= n;i++){
        readInteger(h[i]);
    }
}

int result;
void solve(){
    for(int i = 1;i <= n; i++){
        l[i] = r[n - i + 1] = 1; 
        for(int j = 1;j < i; j++){
            if(h[i] > h[j] && l[i] <= l[j])
                l[i] = l[j] + 1;
            if(h[n - i + 1] > h[n - j + 1] && r[n - i + 1] <= r[n - j + 1])
                r[n - i + 1] = r[n - j + 1] + 1;
        }        
    }
    for(int i = 1;i <= n;i++)
        if(l[i] + r[i] > result)    result = l[i] + r[i];
}

int main(){
    init();
    solve();
    printf("%d",n - result + 1);
    return 0;
}
```

### Problem B. 加分二叉树
```
题目描述
　　设一个n个节点的二叉树tree的中序遍历为（l,2,3,…,n），其中数字1,2,3,…,n为节点编号。每个节点都有一个分数（均为正整数），记第i个节点的分数为di，tree及它的每个子树都有一个加分，任一棵子树subtree（也包含tree本身）的加分计算方法如下：
　　subtree的左子树的加分× subtree的右子树的加分＋subtree的根的分数
　　若某个子树为空，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。
　　试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树tree。要求输出；
　　（1）tree的最高加分
　　（2）tree的前序遍历

输入数据
　　第 1 行：一个整数 n （n＜30），为节点个数。
　　第 2 行： n 个用空格隔开的整数，为每个节点的分数（分数＜100）。
输出数据
　　第 1 行：一个整数，为最高加分（结果不会超过 4,000,000,000 ）。
　　第 2 行： n 个用空格隔开的整数，为该树的前序遍历。
若存在多种前序遍历均为最高加分，则输出字典序最小的前序遍历
样例输入
5
5 7 1 2 10
样例输出
145
3 1 2 4 5
```
代码：
```
#include<stdio.h>
#define D long long
D dp[39][39];
int root[39][39];
int n;
void out_tree(int l,int r){
    if(l>r)return;
    printf("%d ",root[l][r]);
    out_tree(l,root[l][r]-1);
    out_tree(root[l][r]+1,r);
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%lld",&dp[i][i]);
        dp[i][i-1]=1;dp[i+1][i]=1;
        root[i][i]=i;
    }
    for(int l=2;l<=n;l++){
        for(int i=1;i<=n-l+1;i++){ 
            for(int j=i;j<=i+l-1;j++){
                if(dp[j][j]+dp[i][j-1]*dp[j+1][i+l-1]>dp[i][i+l-1]){
                    dp[i][i+l-1]=dp[j][j]+dp[i][j-1]*dp[j+1][i+l-1];
                    root[i][i+l-1]=j;
                }
            }
        }
    }
    printf("%lld\n",dp[1][n]);
    out_tree(1,n);
    printf("\n");
}
```

### Problem C. 采药
```
题目描述
　　辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”
　　如果你是辰辰，你能完成这个任务吗？

输入数据
　　输入的第一行有两个整数 T （ 1 ≤ T ≤ 1000 ）和 M （ 1 ≤ M ≤ 100 ），用一个空格隔开， T 代表总共能够用来采药的时间， M 代表山洞里的草药的数目。接下来的 M 行每行包括两个在 1 到100之间（包括 1 和100）的整数，分别表示采摘某株草药的时间和这株草药的价值。
输出数据
输出包括一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。
样例输入
70 3
71 100
69 1
1 2
样例输出
3
```
代码：
```
#include <iostream>  
#include <stdio.h>  
#include <string.h>  
#include <stdlib.h>  
#include <memory.h>  
#include <math.h>  
#include <queue>  
#include <stack>  
#include <map>  
#include <vector>  
#include <limits.h>  
#include <malloc.h>  
#include <ctype.h>  
#include <float.h>  
#include <memory.h>  
using namespace std;  
   
int i,j,n,m;  
int a[10005];  
int w[10005];  
int f[1000005];  
   
int main(){  
    scanf("%d %d",&m,&n);  
    for(i=1;i<=n;i++)  
        scanf("%d %d",&a[i],&w[i]);  
    for(i=1;i<=n;i++)  
        for(j=m;j>=a[i];j--)  
            f[j]=max(f[j],f[j-a[i]]+w[i]);  
    for(i=1,f[0]=0;i<=m;i++)  
        f[0]=max(f[0],f[i]);  
    printf("%d\n",f[0]);  
    return 0;  
}
```

### Problem D. 数的划分
```
题目描述
将整数n分成k份，且每份不能为空，任意两份不能相同(不考虑顺序)。
例如：n=7，k=3，下面三种分法被认为是相同的。
1,1,5; 1,5,1; 5,1,1;
问有多少种不同的分法。

输入数据
输入 n ， k (6< n≤ 200 ， 2≤ k≤ 6)
输出数据
一个整数，即不同的分法。
样例输入
7 3
样例输出
4
```
代码：
```
#include<iostream>
using namespace std;
int n,k,a[10000],sum=0,ans;
void dfs(int past,int cnt,int num)
{
    if(cnt==1)
    {
        ans++;
        return;
    }
    for(int i=past;i<=num/cnt;i++)
    dfs(i,cnt-1,num-i);
}
int main()
{
    cin>>n>>k;
    dfs(1,k,n);
    cout<<ans;
    return 0;
}
```

### Problem E. 统计单词个数
```
题目描述
　　给出一个长度不超过200的由小写英文字母组成的字母串(约定;该字串以每行20个字母的方式输入，且保证每行一定为20个)。要求将此字母串分成k份(1< k< =40)，且每份中包含的单词个数加起来总数最大(每份中包含的单词可以部分重叠。当选用一个单词之后，其第一个字母不能再用。例如字符串this中可包含this和is，选用this之后就不能包含th)。
　　单词在给出的一个不超过6个单词的字典中。
　　要求输出最大的个数。

输入数据
第一行有二个正整数  (p ， k)
p 表示字串的行数;
k 表示分为 k 个部分。
接下来的 p 行，每行均有 20 个字符。
再接下来有一个正整数 s ，表示字典中单词个数。  (1≤ s≤ 6)
接下来的 s 行，每行均有一个单词。
输出数据
输出一个整数，即最大的个数
样例输入
1 3
thisisabookyouareaoh
4
is
a
ok
sab
样例输出
7
```

代码：
```
#include <iostream>
#include <string>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
string s,q[7];
int p,kk,pp,bj[201][201],sum[201][201],f[201][201];
int comp(string a,string b)
{
    return a.size()<b.size();
}
int main()
{
    cin>>p>>kk;
    for(int i=1;i<=p;i++)
    {
        string ss;
        cin>>ss;
        s+=ss;
    }
    cin>>pp;
    for(int i=1;i<=pp;i++)
        cin>>q[i];
    sort(q+1,q+1+pp,comp);
    for(int i=0;i<s.size();i++)
        for(int j=i;j>=0;j--)
            for(int k=1;k<=pp;k++)
            {
                sum[j+1][i+1]=sum[j+2][i+1];
                if(q[k].size()<=(i-j+1))
                {
                    int pd=1;
                    int h1=0,h2=j;
                    while(h1<q[k].size()&&q[k][h1]==s[h2])  h1++,h2++;
                    if(h1==q[k].size())
                    {
                        sum[j+1][i+1]++;
                        break;
                    }
                }   
            }
    for(int k=1;k<=kk;k++)
        for(int i=1;i<=s.size();i++)
            for(int j=k-1;j<i;j++)
                f[i][k]=max(f[i][k],f[j][k-1]+sum[j+1][i]);
    cout<<f[s.size()][kk]<<endl;
    return 0;
}
```

### Problem F. 马拦过河卒
```
题目描述
　　棋盘上A点有一个过河卒，需要走到目标B点。卒行走的规则：可以向下、或者向右。同时在棋盘上C点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。
　　棋盘用坐标表示，A点(0, 0)、B点(n, m)(n, m为不超过15的整数)，同样马的位置坐标是需要给出的。现在要求你计算出卒从A点能够到达B点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。

输入数据
一行四个数据，分别表示 B 点坐标和马的坐标。
输出数据
一个数据，表示所有的路径条数。
样例输入
6 6 3 3
样例输出
6
```
代码：
```
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<map>
#include<bitset>
#define mk make_pair
#define fi first
#define nd second
#define pii pair<int,int>
#define pb push_back
#define sqr(x) ((x)*(x))
using namespace std;
typedef long long ll;
inline ll read() {ll x = 0; char ch = getchar(), w = 1;while(ch < '0' || ch > '9') {if(ch == '-') w = -1;
ch = getchar();}while(ch >= '0' && ch <= '9') {x = x * 10 + ch - '0';ch = getchar();}return x * w;}
void write(ll x) {if(x < 0) putchar('-'), x = -x;if(x > 9) write(x / 10);putchar(x % 10 + '0');}
inline void writeln(ll x) {write(x);puts("");}
 
int dx[] = {-2, -2, -1, 1, 2,  2,  1, -1};
int dy[] = {-1,  1,  2, 2, 1, -1, -2, -2};
ll f[25][25];
int n, m;
int x, y;
bool vis[25][25];
int main() {
	n = read(), m = read(), x = read(), y = read();
	vis[x][y] = 1;
	for(int i = 0; i < 8; ++i) {
		int nx = x + dx[i];
		int ny = y + dy[i];
		if(nx < 0 || nx > n || ny < 0 || ny > m) continue;
		vis[nx][ny] = 1;
	}
	f[0][0] = 1;
	for(int i = 0; i <= n; ++i)
		for(int j = 0; j <= m; ++j) if(!vis[i][j]){
			if(!(i | j)) continue;
			if(i) f[i][j] = f[i - 1][j];
			if(j) f[i][j] += f[i][j - 1];
		}
	writeln(f[n][m]);
	return 0;
}
```

## 研究生第六次算法作业
### Problem A. 装箱问题
```
题目描述
　　有一个箱子容量为v(正整数，o≤v≤20000)，同时有n个物品(o≤n≤30)，每个物品有一个体积 (正整数)。要求从 n 个物品中，任取若千个装入箱内，使箱子的剩余空间为最小。

输入数据
第一行，一个整数，表示箱子容量；
第二行，一个整数，表示有 n 个物品；
接下来 n 行，分别表示这 n 个物品的各自体积。
输出数据
一个整数，表示箱子剩余空间。
样例输入
24
6
8
3
12
7
9
7
样例输出
0
```
代码：
```
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
int main(int ac,char *av[])
{
    int dp[20001],max_v,n,tmp,i,j;
    while(cin>>max_v>>n){
    memset(dp,0,sizeof(dp));
    for(i=1;i<=n;i++){
        cin>>tmp;
        for(j=max_v;j>=tmp;j--){
          dp[j]=max(dp[j],dp[j-tmp]+tmp);
         }
    }
    cout<<max_v-dp[max_v]<<endl;
    }
    return 0;
}
```

### Problem B. 小胖办证
```
题目描述
xuzhenyi要办个签证。办证处是一座M层的大楼，1< =M< =100。
每层楼都有N个办公室，编号为1..N(1< =N< =500)。每个办公室有一个签证员。
签证需要让第M层的某个签证员盖章才有效。
每个签证员都要满足下面三个条件之一才会给xuzhenyi盖章：

这个签证员在1楼
xuzhenyi的签证已经给这个签证员的正楼下（房间号相同）的签证员盖过章了。
xuzhenyi的签证已经给这个签证员的相邻房间（房间号相差1，楼层相同）的签证员盖过章了。
每个签证员盖章都要收取一定费用，这个费用不超过1000000000。
找出费用最小的盖章路线，使签证生效

输入数据
第 1 行两个整数 M 和 N 。
接下来 M 行每行 N 个整数，第 i 行第 j 个数表示第 i 层的第 j 个签证员收取的费用。
输出数据
按顺序打出你经过的房间的编号，每行一个数。
如果有多条费用最小的路线，输出任意一条。
样例输入
3 4
10 10 1 10
2 2 2 10
1 10 10 10
样例输出
3
3
2
1
1
```

代码：
```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

const int MAXN=505;
const int MAXM=105;
const int INF=(1<<30)-1;
int f[MAXM][MAXN];
int w[MAXM][MAXN];
int n,m;
int ans=INF,p;

void init()
{
    scanf("%d%d",&m,&n);
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++)
            scanf("%d",&w[i][j]);
    memset(f,0x3f,sizeof(f));
}

void DP()
{
    for(int i=1;i<=n;i++)
        f[1][i]=w[1][i];
    for(int i=2;i<=m;i++)
    {
        for(int j=1;j<=n;j++)
            f[i][j]=f[i-1][j]+w[i][j];
        for(int j=2;j<=n;j++)
            f[i][j]=min(f[i][j],f[i][j-1]+w[i][j]);
        for(int j=n-1;j>=1;j--)
            f[i][j]=min(f[i][j],f[i][j+1]+w[i][j]);
    }
    for(int i=1;i<=n;i++)
    {
        if(f[m][i]<ans)
        {
            ans=f[m][i];
            p=i;
        }
    }
}

void print(int x,int y)
{
    if(x==1)
    {
        cout<<y<<endl;
        return;
    }
    if(f[x-1][y]+w[x][y]==f[x][y])
        print(x-1,y);
    else    if(f[x][y-1]+w[x][y]==f[x][y])
        print(x,y-1);
    else
        print(x,y+1);
    cout<<y<<endl;
}

int main()
{
    init();
    DP();
    print(m,p);
}
     
```

### Problem C. 三取方格数
```
题目描述
设有N*N的方格图，我们将其中的某些方格填入正整数，
而其他的方格中放入0。
某人从图得左上角出发，可以向下走，也可以向右走，直到到达右下角。
在走过的路上，他取走了方格中的数。（取走后方格中数字变为0）
此人从左上角到右下角共走3次，试找出3条路径，使得取得的数总和最大。

输入数据
第一行 :N (4≤ N≤ 20)
接下来一个 N∗N 的矩阵，矩阵中每个元素不超过 80 ，不小于 0
输出数据
一行，表示最大的总和。
样例输入
4
1 2 3 4
2 1 3 4
1 2 3 4
1 3 2 4
样例输出
39
样例说明
多进程DP
```

代码：
```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
const int maxn=25;
int f[maxn*2][maxn][maxn][maxn];
int map[maxn][maxn];
int N;
int main(){
    scanf("%d",&N);
    for(int i=1;i<=N;i++){
        for(int j=1;j<=N;j++){
            scanf("%d",&map[i][j]);
        }
    }
    f[1][1][1][1]=map[1][1];
    for(int step=2;step<=2*N-1;step++){
        for(int x1=max(1,step-N+1);x1<=min(N,step);x1++){
            for(int x2=max(1,step-N+1);x2<=min(N,step);x2++){
                for(int x3=max(1,step-N+1);x3<=min(N,step);x3++){
                    int delta=map[x1][step-x1+1]+map[x2][step-x2+1]+map[x3][step-x3+1];
                    if(x1==x2) delta-=map[x1][step-x1+1];
                    if(x1==x3) delta-=map[x1][step-x1+1];
                    if(x2==x3) delta-=map[x2][step-x2+1];
                    if(x1==x2&&x1==x3) delta+=map[x1][step-x1+1];
                    f[step][x1][x2][x3]=max(f[step-1][x1][x2][x3],max(f[step-1][x1-1][x2][x3],
                                        max(f[step-1][x1][x2-1][x3],max(f[step-1][x1][x2][x3-1],
                                        max(f[step-1][x1-1][x2-1][x3],max(f[step-1][x1-1][x2][x3-1],
                                        max(f[step-1][x1][x2-1][x3-1],f[step-1][x1-1][x2-1][x3-1])))))))+delta;
                    
                    
                }
            }
        }
    }
    cout<<f[2*N-1][N][N][N];
    return 0;
}

```

### Problem D. 小胖守皇宫
```
题目描述
huyichen世子事件后，xuzhenyi成了皇上特聘的御前一品侍卫。

皇宫以午门为起点，直到后宫嫔妃们的寝宫，呈一棵树的形状；某些宫殿间可以互相望见。大内保卫森严，三步一岗，五步一哨，每个宫殿都要有人全天候看守，在不同的宫殿安排看守所需的费用不同。

可是xuzhenyi手上的经费不足，无论如何也没法在每个宫殿都安置留守侍卫。

帮助xuzhenyi布置侍卫，在看守全部宫殿的前提下，使得花费的经费最少。

输入数据
输入文件中数据表示一棵树，描述如下：

第 1 行  n ，表示树中结点的数目。

第 2 行至第 n+1 行，每行描述每个宫殿结点信息，依次为：该宫殿结点标号 i （ 0< i≤ n ），在该宫殿安置侍卫所需的经费 k ，该边的儿子数 m ，接下来 m 个数，分别是这个节点的 m 个儿子的标号 r1 ， r2 ，...， rm 。

对于一个 n （ 0 < n ≤ 1500 ）个结点的树，结点标号在 1 到 n 之间，且标号不重复。

输出数据
输出文件仅包含一个数，为所求的最少的经费。
样例输入
6
1 30 3 2 3 4
2 16 2 5 6
3 5 0
4 4 0
5 11 0
6 5 0
样例输出
25
样例说明
如图
```
代码：
```
#include <stdio.h>
#include <string.h>
#define MAXN 2000
#define INF 999999
struct node
{
    int from;
    int to;
    int next; 
}edge[MAXN];
int n,pos,m,r,k,cnt,ans,t;
int head[MAXN],val[MAXN],in[MAXN],dp[MAXN][3];
int min(int a,int b){return a<b?a:b;}
void init()
{
    memset(head,-1,sizeof(head));
    cnt=1;
}
void addedge(int from,int to)
{
    edge[cnt].from=from;
    edge[cnt].to=to;
    edge[cnt].next=head[from];
    head[from]=cnt++;
}
void dfs(int u)
{
    dp[u][0]=val[u];
    dp[u][1]=INF;
    for(int i=head[u];i!=-1;i=edge[i].next)
    {
        int v=edge[i].to;
        dfs(v);
        dp[u][0]+=min(dp[v][2],min(dp[v][0],dp[v][1]));
        dp[u][2]+=min(dp[v][1],dp[v][0]); 
    }
    for(int i=head[u];i!=-1;i=edge[i].next)
    {
        int v=edge[i].to;
        dp[u][1]=min(dp[u][1],dp[u][2]-min(dp[v][1],dp[v][0])+dp[v][0]);
    }
}
int main()
{
    init();
    scanf("%d",&n);
    int t=n;
    while(t--)
    {
        scanf("%d",&pos);
        scanf("%d%d",&val[pos],&m);
        for(int i=1;i<=m;i++)
        {
            scanf("%d",&r);
            addedge(pos,r);
            in[r]++;
        }       
    }       
    for(int i=1;i<=n;i++)
    {
        if(!in[i])
        {
            dfs(i);
            printf("%d\n",min(dp[i][0],dp[i][1]));
            return 0;
        }
    }    
    return 0;
} 

```

### Problem E. 买蛋糕
```
题目描述
　　野猫过生日，大家当然会送礼物了（咳咳，没送礼物的同志注意了哈！！），由于不知道送什么好，又考虑到实用性等其他问题，大家决定合伙给野猫买一个生日蛋糕。大家不知道最后要买的蛋糕的准确价格，而只会给蛋糕估价，即要买一个不超过多少钱的蛋糕。众OIer借此发挥：能否用最少的钱币数去凑成估价范围内的所有价值，使得不管蛋糕价值多少，都不用找钱……
　　现在问题由此引出：对于一个给定的n，能否用最少的不等的正整数去组成n以内（包括n）的所有的正整数呢？如果能，最少需要多少个正整数，用最少个数又有多少不同的组成方法呢？

输入数据
只有一行包含一个整数 n (1≤ n≤ 1000) 。
输出数据
一行两个数，第一个数是最少需要多少个数，第二个数是用最少个数的组成方案个数。两个答案用空格分隔。
样例输入
6
样例输出
3 2
样例说明
最少用三个数，有两种方法，分别是：1，2，3和1，2，4。
对于1，2，3有1，2，3，1＋3，2＋3，1＋2＋3；
对于1，2，4有1，2，1＋2，4，1＋4，2＋4。
```

代码：
```
#include<algorithm>
#include<cstring>
#include<cmath>
#include<iostream>
#include<cstdio>
using namespace std;
const int maxn=1005;
int n,ans,tot;
int f[11][maxn][maxn];

int main() {
	cin>>n;
	ans=(int)log2(n)+1;
	f[1][1][1]=1;
	for(int i=1; i<ans; i++)
		for(int j=i; j<=(1<<(i-1)); j++)
			for(int k=i; k<=((1<<i)-1); k++)
				if(f[i][j][k])
					for(int p=j+1; p<=k+1; p++) {
						if(p+k<=n)
							f[i+1][p][k+p]+=f[i][j][k];
						else
							f[i+1][p][n]+=f[i][j][k];
					}
	for(int i=1; i<=n; i++)
		tot+=f[ans][i][n];
	cout<<ans<<" "<<tot;
	return 0;
}

```

### Problem F. 岳麓山上打水
```
题目描述
　　今天天气好晴朗，处处好风光，好风光！蝴蝶儿忙啊，蜜蜂也忙，信息组的同学们更加忙。最近，由于XX原因，大家不得不到岳麓山去提水。55555555~，好累啊。
　　信息组有一个容量为q升的大缸，由于大家都很自觉，不愿意浪费水，所以每次都会刚好把缸盛满。但是，信息组并没有桶子（或者瓢）来舀水，作为组内的生活委员，你必须肩负重任，到新一佳去买桶子。
　　新一佳有p种桶子，每种桶子都有无穷多个^_^，且价钱一样。由于大家都很节约，所以你必须尽量少买桶子。如果有多种方案，你必须选择“更小”的那种方案，即：把这两个方案的集合（不同大小的桶子组成）按升序排序，比较第一个桶，选择第一个桶容积较小的一个。如果第一个桶相同，比较第二个桶，也按上面的方法选择。否则继续这样的比较，直到相比较的两个桶不一致为止。例如，集合{3，5，7，三} 比集合 {3，6，7，8} 要好。
　　为了把缸装满水，大家可以先从岳麓山的井里把桶装满水提回来，然后倒进缸里。为了不十分麻烦或者浪费宝贵的水资源，大家决不把缸里的水倒出来或者把桶里的水倒掉，也不会把桶里的水再倒回井中，（这样会污染井水）。当然，一个桶可以使用多次。例如，用一个容积为 1 升的桶可以将任意容量的大缸装满水。而其它的组合就要麻烦些。

输入数据
第 1 行 1 个数 q (q< 2× 104) 。
第 2 行 1 个数 p (p≤ 100) 。
接下来 p 行，每行一个数，依次为每个桶的容积。
输出数据
共 1 行，每两个数间用空格分隔，第 1 个数 k 为最少的桶的数量，接下来 k 个数从小到大输出每个桶的容量。
样例输入
16
3
3
5
7
样例输出
2 3 5
```
代码：
```
#include<bits/stdc++.h>
#define read read()
using namespace std;

int read 
{
	int f=1,x=0;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=x*10+ch-'0'; ch=getchar();}
	return x*=f;
}

int n,m,ub;
int v[105],ans[105],ex[20005];

bool judge(int l)
{
	if(ex[l]!=-1) return ex[l];
	if(l==0) return ex[l]=1;
	for(int i=0;i<ub;i++)
		if(l>=ans[i]&&judge(l-ans[i])) return ex[l]=1;
	return ex[l]=0;
}

void dfs(int tot,int now)
{
	if(now==ub){
	    memset(ex,-1,sizeof(ex));
		if(judge(n))
		{
			printf("%d",ub);
			for(int i=0;i<ub;i++)
				printf(" %d",ans[i]);
			exit(0);
		}
		return;
	}
	if(tot>=m) return;
	ans[now]=v[tot];
	dfs(tot+1,now+1);
	dfs(tot+1,now);
}

int main()
{
	n=read;
	m=read;
	for(int i=0;i<m;i++){
		v[i]=read;
	}
	sort(v,v+m);
	for(ub=1;ub<=m;ub++){
		dfs(0,0);
	}
	return 0;
}

```

## 研究生第七次算法作业
### Problem A. 公路巡逻
```
题目描述
　　在一条没有分岔的高速公路上有n个关口，相邻两个关口之间的距离都是10km。所有车辆在这条高速公路上的最低速度为60km/h，最高速度为120km/h，并且只能在关口处改变速度。巡逻的方式是在某个时刻Ti从第ni个关口派出一辆巡逻车匀速驶抵第(ni+1)个关口，路上耗费的时间为ti秒。
　　两辆车相遇是指它们之间发生超车或者两车同时到达某关口（同时出发不算相遇）。
　　巡逻部门想知道一辆于6点整从第1个关口出发去第n个关口的车（称为目标车）最少会与多少辆巡逻车相遇，请编程计算之。假设所有车辆到达关口的时刻都是整秒。

输入数据
输入第一行为两个用空格隔开的整数，分别为关口数 n 和巡逻车数 m 。（ 1< n< 50,1< m< 300 ），接下来的 m 行每一行为一辆巡逻车的信息（按出发位置递增排序），格式为ni　Ti　ti，三项用空格隔开，分别表示第 i 辆巡逻车的出发位置、出发时刻和路上耗费的时间，其中 ni 和 ti 为整数， Ti 形如hhmmss，表示时、分、秒，采用 24 小时制，不足两位的数用前置 0 补齐。（ 1≤ ni< n,05:00:00≤ Ti≤ 23:00:00,300≤ ti≤ 600 ）
输出数据
输出第一行为目标车与巡逻车相遇次数。第二行为目标车与巡逻车相遇次数最少时最早到达第 n 个关口的时刻（格式同输入中的 Ti ）。
样例输入
3 2
1 060000 301
2 060300 600
样例输出
0
061301
```
代码
```
#include<iostream>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <ctime>
#include <cctype>
#include <climits>
#include <algorithm>
#include <map>
#include <queue>
#include <vector>
#include <string>
#include <cstring>
#include <sstream>
#include <fstream>
using namespace std;
const int INF=66666666;
struct node {
    int start,end;
} car[305][305];
int n,m;
int dp[55][33000]={0};
int num[305]={0};
int change(int time)
{
    int h,m,s;
    h=time/10000;
    time-=h*10000;
    h-=6;
    m=time/100;
    time-=m*100;
    s=time;
    return (h*3600+m*60+s);
}
int changeBack(int T)
{
    int h,m,s;
    h=T/3600;
    T-=h*3600;
    h+=6;
    m=T/60;
    T-=m*60;
    s=T;
    return h*10000+m*100+s;
}
int main()
{
    scanf("%d %d",&n,&m);
    int n600=n*600;
    int ni,Ti,ti;
    memset(dp,50,sizeof(dp));
    for(int i=0; i<m; i++) {
        scanf("%d %d %d",&ni,&Ti,&ti);
        ni--;
        Ti=change(Ti);
        car[ni][num[ni]].start=Ti;
        car[ni][num[ni]].end=ti+Ti;
        num[ni]++;//ni个站点出发有几辆车
    }
    dp[0][0]=0;
    n--;
    bool b=false;
    for(int i=0; i<n; i++) {
        for(int j=i*300,i600=i*600; j<=i600; j++) {
            for(int k=300; k<=600; k++) {
                int times=0,jk=j+k;
                for(int p=0; p<num[i]; p++) {
                    if((car[i][p].start>=j&&car[i][p].end>jk)||(car[i][p].start<=j&&car[i][p].end<jk))
                        continue;//没有超车
                    else
                        times++;//超车或同时到达
                }
                dp[i+1][jk]=min(dp[i+1][jk],dp[i][j]+times);
                if (dp[i+1][jk]==0) {
                    for (int p=jk+1,i602=i600+600;p<=i602;p++) {
                        dp[i+1][p]=0;
                    }   
                    b=true;
                    break;
                }
            }
            if (b) break;
        }
        if (b) {
            b=false;
            continue;
        }
    }
    int result=INF;
    int minTime;
    for(int i=n*300,n601=n600-600; i<=n601; i++) {
        if(result>dp[n][i]) {
            result=dp[n][i];
            minTime=i;
        }
    }
    int printTime=changeBack(minTime);
    printf("%d\n",result);
    if (printTime<100000) printf("0");
    printf("%d\n",printTime);
    return 0;
}

```

### Problem B. 邮票面值设计
```
题目描述
　　给定一个信封，最多只允许粘贴N张邮票，计算在给定M（N+M< =10）种邮票的情况下（假定所有的邮票数量都足够）,如何设计邮票的面值，能得到最大max ，使得1～max之间的每一个邮资值都能得到。
例如，N=3，M＝2，如果面值分别为1分、4分，则在l分～6分之间的每一个邮资值都能得到（当然还有8分、9分和12分）：如果面值分别为1分、3分，则在1分～7分之间的每一个邮资值都能得到。可以验证当N=3，M＝2时，7分就是可以得到连续的邮资最大值，所以MAX=7，面值分别为l分、3分。
样例输入：共一行，两个整数，分表为N与M的值。

输入数据
一行，分别为 N,M 。
输出数据
两行。
第一行为 m 种邮票的面值，按升序排列，各数之间用一个空格隔开。
第二行为最大值。
样例输入
3 2
样例输出
1 3
max=7
```
代码：
```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int MAXN=12;
const int MAXV=505;
int Ans[MAXN],ans,ansl;
int g[MAXN];
int f[MAXV];
int n,m;
void init()
{
    cin>>n>>m;
}

int dp(int l)
{
    memset(f,0x3f,sizeof(f));   f[0]=0;
    int maxw=1;
    for(;;maxw++)
    {
        for(int i=1;i<=l;i++)
            if(maxw>=g[i])
                f[maxw]=min(f[maxw],f[maxw-g[i]]+1);
        if(f[maxw]>n)
            return maxw-1;
    }
}

void dfs(int cur)
{
    int maxw=dp(cur);
    if(maxw>=ans&&cur==m)//*
    {
        ans=maxw;   ansl=cur;
        memcpy(Ans,g,sizeof(int)*(cur+1));
    }
    if(cur==m)
        return;
    for(int i=g[cur]+1;i<=maxw+1;i++)
    {
        g[cur+1]=i;
        dfs(cur+1);
    }
}

void out()
{
    for(int i=1;i<=ansl;i++)
        cout<<Ans[i]<<" ";
    cout<<endl;
    cout<<"MAX="<<ans<<endl;
}

int main()
{
    init();
    g[1]=1; dfs(1);
    out();
}
     
```

### Problem C. 选课
```
题目描述
学校实行学分制。每门的必修课都有固定的学分，同时还必须获得相应的选修课程学分。学校开设了N（N< 300）门的选修课程，每个学生可选课程的数量M是给定的。学生选修了这M门课并考核通过就能获得相应的学分。

　　在选修课程中，有些课程可以直接选修，有些课程需要一定的基础知识，必须在选了其它的一些课程的基础上才能选修。例如《Frontpage》必须在选修了《Windows操作基础》之后才能选修。我们称《Windows操作基础》是《Frontpage》的先修课。每门课的直接先修课最多只有一门。两门课也可能存在相同的先修课。每门课都有一个课号，依次为1，2，3，…。 例如:

表中1是2的先修课，2是3、4的先修课。如果要选3，那么1和2都一定已被选修过。 　　你的任务是为自己确定一个选课方案，使得你能得到的学分最多，并且必须满足先修课优先的原则。假定课程之间不存在时间上的冲突。

输入数据
输入文件的第一行包括两个整数N、M（中间用一个空格隔开）其中1≤N≤300,1≤M≤N。
以下 N 行每行代表一门课。课号依次为 1 ， 2 ，…， N 。每行有两个数（用一个空格隔开），第一个数为这门课先修课的课号（若不存在先修课则该项为 0 ），第二个数为这门课的学分。学分是不超过 10 的正整数。
输出数据
输出文件每行只有一个数。第一行是实际所选课程的学分总数。以下各行的数，表示所选课程的课号。
样例输入
7 4
2 2
0 1
0 4
2 1
7 1
7 6
2 2
样例输出
13
2
6
7
3
```
代码：
```
/*
一道树形dp，因为每门课的先修课最多只有一节，则说明这是个树结构
对于读入的边，我们先将多叉树建立成二叉树
原则是左儿子右兄弟
然后再定义状态f表示以i课程为父亲结点的子树上选j门课程的最多学分
则有状态转移方程
f[i][j]=max(f[left][j-k-1]+f[right][k]+score[i](0<=k<=j-1),f[right][j])
方程含义：1、取当前i节点，则剩下的j-1们课程，在孩子中选j-k-1门，在兄弟中选k门。
          2、不取当前节点，则只能在兄弟中选j门。
k用来表示的是分别分配在某个节点上的左右子树的选择课程树
注意还有个f[right][j]即表示不选这门课程而选择它的右兄弟
原理上两种情况是根本上相同可合并的但是实际实现中没有那么方便
所以我们可以自顶向下用dfs进行树的遍历递归求解
*/
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

const int maxn=305;
struct node
{
    int l,r,v;
}tree[maxn];
int n,m;
int f[maxn][maxn];

int dfs(int x,int y)
{
    if(!y||x<0)
        return 0;
    if(!x)
        return dfs(tree[x].l,y);
    if(f[x][y])
        return f[x][y];
    f[x][y]=dfs(tree[x].r,y);
    for(int i=0;i<y;i++)
        f[x][y]=max(f[x][y],dfs(tree[x].l,i)+tree[x].v+dfs(tree[x].r,y-i-1));
    return f[x][y];
}

int main()
{
    memset(tree,-1,sizeof(tree));
    cin>>n>>m;
    int fa,v;
    for(int i=1;i<=n;i++)
    {
        cin>>fa>>v;
        tree[i].r=tree[fa].l;
        tree[fa].l=i;
        tree[i].v=v;
    }
    cout<<dfs(0,m)<<endl;//0表示入口，0的子节点表示第一层
    return 0;
}
```

### Problem D. Domino
```
题目描述
JSOI2005夏令营的一天，JYY和lhc一起玩多米诺游戏。
lhc提出一个令JYY抓头的问题：有一个m 行n 列的矩形方格棋盘，1< =m,n< =10^9，用1*2 的骨牌(可横放或竖放)完全覆盖，骨牌不能重叠，有多少种不同的覆盖的方法。JYY暗想，这题范围这么大，公式又那么难找，这怎么办呢？
于是他要求lhc做出让步，lhc不得不做出让步，现在1< =n< =10^9，1< =m< =5。于是JYY高兴地在5分钟内解决了这个问题，不幸的是他把这个程序弄丢了，但他从不把做过的东西再做一遍，于是他把任务交给了你。
请你帮助JYY编程解决:)
lhc不想看到长串的高精度数，你只需要求出覆盖方法总数 mod p 的值即可。

输入数据
一行，三个整数数 n ， m ， p ， 1≤ n≤ 109 ， 1≤ m≤ 5 ， 1≤ p< 104 。
输出数据
一个整数，总数 mod p 的结果。
样例输入
7 2 10
样例输出
1
```
代码：
```
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<cstring>
using namespace std;
struct node
{
    long long a[35][35];
    node()
    {
        memset(a,0,sizeof(a));
    }
};
int he;
long long p;
int s[8]={0,3,6,12,15,24,27,30};
node chengfa(node a,node b)
{
    node c;
    for(int i=0;i<he;i++)
    {
        for(int j=0;j<he;j++)
        {
            for(int k=0;k<he;k++)
            {
                c.a[i][j]=(c.a[i][j]+a.a[i][k]*b.a[k][j])%p;
            }
        }
    }
    return c;
}
int main()
{
    int m;long long n;
    node pre,ans;
    he=1;
    scanf("%lld%d%lld",&n,&m,&p);
    for(int i=1;i<=m;i++)he*=2;
    for(int i=0;i<he;i++)ans.a[i][i]=1;
    for(int i=0;i<he;i++)
    {
        for(int j=0;j<he;j++)
        {
            if(((~i)&j)==((~i)&(he-1)))
            {
                int bk=0;
                for(int k=0;k<8;k++)
                {
                    if((i&j)==s[k])bk=bk||(i&j)==s[k];
                }
                pre.a[i][j]=bk;
            }
        }
    }
    long long x=n;
    while(x>0)
    {
        if(x%2==1)ans=chengfa(pre,ans);
        pre=chengfa(pre,pre);
        x/=2;
    }
    printf("%lld\n",ans.a[he-1][he-1]);
    return 0;
}
```

### Problem E. “非常男女”计划
```
题目描述
　　Matrix67已经当过多次“媒人”了。他因此获得了许多经验。例如，距Matrix67观察，身高相近的人似乎比较合得来。
　　Matrix67在学校策划了一次大型的“非常男女”配对活动。对于这次活动的参与者，Matrix67有自己独特的选择方式。他希望能选择男女人数相等且身高都很接近的一些人。这种选择方式实现起来很简单。他让学校的所有人按照身高排成一排，然后从中选出连续的若干个人，使得这些人中男女人数相等。Matrix67当然希望他能选出的人越多越好。请编写程序告诉他，他最多可以选出多少人来。

输入数据
　　第一行有一个正整数 n ，代表学校的人数。
　　第二行有 n 个用空格隔开的数，这些数只能是 0 或 1 ，其中， 0 代表一个女生， 1 代表一个男生。

　　对于 30 的数据， n≤ 100 ；
　　对于 50 的数据， n≤ 1 000 ；
　　对于100%的数据， n≤ 100 000 。
输出数据
　　输出一个非负整数。这个数表示在输入数据中最长的一段男女人数相等的子序列长度。
　　如果不存在男女人数相等的子序列，请输出 0 。
样例输入
9
0 1 0 0 0 1 1 0 0
样例输出
6
样例说明
样例说明：
　　选择第2个人至第7个人可以获得男女人数均为3的最长子序列。
```
代码：
```
#include<iostream>
using namespace std;
int q[100010],num[200010][2],pan[200010];
int main()
{
    int n,i,a,ans=0;
    cin>>n;
    pan[100000]=1;
    q[0]=100000;
    for(i=1;i<=n;i++)
     {
        cin>>a;
        if(a)
         q[i]=q[i-1]+1;
        else
         q[i]=q[i-1]-1;
        if(!pan[q[i]])
         {
          num[q[i]][0]=i;
          pan[q[i]]=1;
         }
        else
         num[q[i]][1]=i;
     }
     for(i=0;i<=200000;i++)
      ans=max(ans,num[i][1]-num[i][0]);
    cout<<ans;
    return 0;
}
```

### Problem F. 最佳课题选择
```
题目描述
　　Matrix67要在下个月交给老师n篇论文，论文的内容可以从m个课题中选择。由于课题数有限，Matrix67不得不重复选择一些课题。完成不同课题的论文所花的时间不同。具体地说，对于某个课题i，若Matrix67计划一共写x篇论文，则完成该课题的论文总共需要花费Ai*x^Bi个单位时间（系数Ai和指数Bi均为正整数）。给定与每一个课题相对应的Ai和Bi的值，请帮助Matrix67计算出如何选择论文的课题使得他可以花费最少的时间完成这n篇论文。

输入数据
　　第一行有两个用空格隔开的正整数 n 和 m ，分别代表需要完成的论文数和可供选择的课题数。
　　以下 m 行每行有两个用空格隔开的正整数。其中，第 i 行的两个数分别代表与第 i 个课题相对应的时间系数 Ai 和指数 Bi 。
　　对于 30 的数据， n≤ 10,m≤ 5 ；
　　对于100%的数据， n≤ 200 ， m≤ 20 ， Ai≤ 100 ， Bi≤ 5 。
输出数据
　　输出完成 n 篇论文所需要耗费的最少时间。
样例输入
10 3
2 1
1 2
2 1
样例输出
19
样例说明
样例说明：
　　4篇论文选择课题一，5篇论文选择课题三，剩下一篇论文选择课题二，总耗时为24^1+11^2+2*5^1=8+1+10=19。可以证明，不存在更优的方案使耗时小于19。
```
代码：
```
#include <cmath>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <limits>
using namespace std;

struct node1{
 int a,b;
}a[21];


int main(){
   int n,m;
   double c[21][201],f[21][201];
   scanf("%d%d",&n,&m);
for (int i=1;i<=m;i++){
   scanf("%d%d",&a[i].a,&a[i].b);
   for (int j=1;j<=n;j++)
    c[i][j]=double(a[i].a)*pow(double(j),double(a[i].b));
}
memset(f,0,sizeof(f));
for (int i=0;i<=m;i++)
  for (int j=1;j<=n;j++)
    f[i][j]=(numeric_limits<double>::max)();
  for (int i=1;i<=m;i++)
    for (int j=1;j<=n;j++)
     {
        f[i][j]=min(f[i][j],f[i-1][j]);
         for (int k=1;k<=j;k++)
         f[i][j]=min(f[i][j],f[i-1][j-k]+c[i][k]);
}
printf("%.0lf\n",f[m][n]);
}
```

## 研究生算法第一次在线测试
### A - 打卡题
```
题目描述
给你一个n行m列的矩阵，顺时针旋转90度后输出

输入数据
第一行为两个整数n,m. 0<n,m<100
接下来有n行，每行m个正整数，每个数不超过100

输出数据
旋转后的矩阵

样例输入
2 3
1 2 3
4 5 6
样例输出
4 1
5 2
6 3
```
代码：
```
#include <iostream>
#include <algorithm>
using namespace std;
int main()
{
    int A[101][101], n, m, i, j;
    cin >> n >> m;
    for(i=0;i<n;i++)
        for(j=0;j<m;j++)
            cin >> A[i][j];
    for(i=0;i<m;i++){
        for(j=0;j<n;j++){
            cout << A[n-1-j][i] << " ";
        }
        cout << endl;
    }
}
```
### Problem B. 课堂作业-2-C
```
题目描述
具体规则如下:
每一行都用到1,2,3,4,5,6,7,8,9，位置不限，
每一列都用到1,2,3,4,5,6,7,8,9，位置不限，
每3×3的格子（共九个这样的格子）都用到1,2,3,4,5,6,7,8,9，位置不限，
游戏的过程就是用1,2,3,4,5,6,7,8,9填充空白，并要求满足每行、每列、每个九宫格都用到1,2,3,4,5,6,7,8,9。
如下是一个正确的数独:
5 8 1 4 9 3 7 6 2
9 6 3 7 1 2 5 8 4
2 7 4 8 6 5 9 3 1
1 2 9 5 4 6 3 7 8
4 3 6 1 8 7 2 9 5
7 5 8 3 2 9 1 4 6
8 9 2 6 7 1 4 5 3
6 1 5 9 3 4 8 2 7
3 4 7 2 5 8 6 1 9

输入数据
输入 n 个数独，你来验证它是否违反规则.
第一行为数独个数，第二行开始为第一个数独，之后为第二个，至第 n 个.
注意！每个数独之间有一个回车隔开!
输出数据
若正确则输出”Right”若不正确则输出”Wrong” 输出一个换一行
样例输入
2
5 8 1 4 9 3 7 6 2
9 6 3 7 1 2 5 8 4
2 7 4 8 6 5 9 3 1
1 2 9 5 4 6 3 7 8
4 3 6 1 8 7 2 9 5
7 5 8 3 2 9 1 4 6
8 9 2 6 7 1 4 5 3
6 1 5 9 3 4 8 2 7
3 4 7 2 5 8 6 1 9

1 2 3 4 5 6 7 8 9
2 3 4 5 6 7 8 9 1
3 4 5 6 7 8 9 1 2
4 5 6 7 8 9 1 2 3
5 6 7 8 9 1 2 3 4
6 7 8 9 1 2 3 4 5
7 8 9 1 2 3 4 5 6
8 9 1 2 3 4 5 6 7
9 1 2 3 4 5 6 7 8
样例输出
Right
Wrong
样例说明
1< =n< =20 （输入的数独个数）
不论输入的数独是错误的还是正确的,数据都保证每个数在1-9之间,即只会出现因为有相同的数而导致违反规则,而不会因为数字超出了1-9的范围而违反规则.
```
代码：
```

#include <stdio.h>
char verity(char data[81]){
    long right=0,right2=0;
    //验证横竖
    for(int i=0;i<9;i++){
        for(int j=0;j<9;j++){
            //i,j在此处既表示横行，又表示竖列
            right+=1<<data[i*9+j];
            right2+=1<<data[j*9+i];
        }
        //1<<1+1<<2+1<<3+...+1<<9=(1<<10)-2=1022.
        if(right!=(1<<10)-2||right2!=(1<<10)-2)
            return 0;
        right=right2=0;
    }
    right=0;
    //验证九宫格
    for(int a=0;a<3;a++){
        for(int b=0;b<3;b++){
            //a,b表示第a行第b列个九宫格
            //i,j是每个九宫格内的行列数
            for(int i=a*3;i<a*3+3;i++){
                for(int j=b*3;j<b*3+3;j++){
                    right+=1<<data[i*9+j];
                }
                
            }
            if(right!=(1<<10)-2)
                    return 0;
                right=0;
        }
    }
    return 1;

}
int main(int argc, char* argv[])
{
    int N;
    scanf("%d",&N);
    //不用[N]，我在本地调试时用的VC++不支持C99标准
    char data[20][81];
    //输入数据
    for(int j=0;j<N;j++){
        for(int i=0;i<81;i++){
            scanf("%d",&data[j][i]);
        }
        //验证
        if(verity(data[j]))
            printf("Right");
        else
            printf("Wrong");
        printf("\n");
    }
    return 0;
}

```

### Problem C. 课堂作业-4-2
```
题目描述
在桌子上有1摞卡片，每个卡片有一个正整数编号，从上到下卡片的编号为1到n，现在进行n次操作，每次操作先扔掉最顶端的卡片，然后将新的最顶端的卡片（如果有）放到这摞卡片的底部。 设第i次操作扔掉了编号为j的卡片（i从1开始），那么这次操作能加的分数为j%i分，求n次操作完成后的总分。

输入数据
一个正整数n，n<1000000

输出数据
每次扔掉卡片的编号，中间用空格分隔

样例输入
7
样例输出
18
样例说明
最后的总分可能会超出int的范围
```
代码：
```
#include <bits/stdc++.h>
using namespace std;
deque<long long>qunea;

int main(){
    long long n, startNum;
    startNum=0;
    cin>>n;
    long long i;
    for(i = 0; i< n; i++){
        qunea.push_back(i + 1);
    }
    for(i = 0;i< n; i++){
    long long j = qunea.front();
        startNum += j % (i + 1);
        qunea.pop_front();
        j = qunea.front();
        qunea.push_back(j);
        qunea.pop_front();
    }
    cout << startNum << endl;
    return 0;
}
```

### Problem D. 解方程
```
题目描述
设x为一个十进制正整数，定义s(x)为x的每一位上的数字之和，如s(123) = 1+2+3 = 6 对于如下方程：x = b*(s(x)^a)+c 给出a,b,c的值，要求找出[1,999999999]内所有符合条件的x，并从小到大输出

输入数据
三个正整数，分别代表a,b,c 1<=a<=5 1<=b<=10000 -10000<=c<=10000

输出数据
第一行为一个正整数n，代表符合条件的x的个数 第二行为n个递增的数，代表所有符合条件的x

样例输入
3 2 8
样例输出
3
10 2008 13726
```
代码：
```
```

### Problem E. 课堂作业-9-1
```
题目描述
楼梯有n阶，可以一步上一阶、两阶或三阶，问有多少种不同的走法
由于答案很大，mod(1e9+7)输出

输入数据
一个正整数n，代表楼梯的阶数，n<=1000000

输出数据
方案数

样例输入
3
样例输出
4
```
代码：
```
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int nums = Integer.parseInt(scanner.nextLine());
        System.out.println(countWays(nums));
    }

    public static int countWays(int n) {
        if (n == 1){
            return 1;
        }
        if (n == 2){
            return 2;
        }
        if (n == 3){
            return 4;
        } 
        int mod = 1000000007;
        int firsts = 1;
        int seconds = 2;
        int thirds = 4;
        int result = 0;
        for (int i = 4; i <= n; i++) {
            result = (firsts + seconds) % mod + thirds % mod;
            firsts = seconds % mod;
            seconds = thirds % mod;
            thirds = result;
        }
        return result % mod;
    }
}
```

### Problem F. 包裹快递
```
题目描述
　　一个快递公司要将n个包裹分别送到n个地方，并分配给邮递员小K一个事先设定好的路线，小K需要开车按照路线给的地点顺序相继送达，且不能遗漏一个地点。小K得到每个地方可以签收的时间段，并且也知道路线中一个地方到下一个地方的距离。若到达某一个地方的时间早于可以签收的时间段，则必须在这个地方停留至可以签收，但不能晚于签收的时间段，可以认为签收的过程是瞬间完成的。
　　为了节省燃料，小K希望在全部送达的情况下，车的最大速度越小越好，就找到了你给他设计一种方案，并求出车的最大速度最小是多少。

输入数据
第 1 行为一个正整数 n (n <2× 105) ，表示需要运送包裹的地点数。
　　下面 n 行，第 i+1 行有 3 个正整数 xi ， yi ， si ，表示按路线顺序给出第 i 个地点签收包裹的时间段为 [xi, yi] ，即最早为距出发时刻 xi ，最晚为距出发时刻 yi ，从前一个地点到达第 i 个地点距离为 si ，且保证路线中 xi 递增。
　　可以认为 s1 为出发的地方到第 1 个地点的距离，且出发时刻为 0 。
输出数据
仅包括一个整数，为车的最大速度最小值，结果保留两位小数。
样例输入
3
1 2 2
6 6 2
7 8 4
样例输出
2.00
样例说明
　　第一段用1的速度在时间2到达第1个地点，第二段用0.5的速度在时间6到达第2个地点，第三段用2的速度在时间8到达第3个地点。
```
代码：
```
# include <cstdio>
# include <cmath>
# include <algorithm>
# include <cstdlib>
# include <cstring>
using namespace std;
# define N 200008
# define ac 0.000001
int n=0;
long double x[N]={0},y[N]={0},s[N]={0}; 
long double l=0.0,r=10000000000,ans;
long double p=0;

bool pd(double v)
{
    for(int i=1;i<=n;i++)
    {
        p+=s[i]/v;
        if(p>y[i]) return 0;
        if(p<x[i]) p=x[i];
    }
    return 1;
}

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%llf%llf%llf",&x[i],&y[i],&s[i]);
    }
    while(r-l>=ac)
    {
        double m=(l+r)/2.0;
        p=0;
        bool b=pd(m);
        if(b)r=m-ac,ans=r;
        else
        {
            l=m+ac;
        }
    }
    printf("%.2llf",ans);
    return 0;
}      
```

## 研究生第八次算法作业—贪心算法 
### Problem A. 花生采摘
```
题目描述
　　鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生!——熊字”。
　　鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格(如图1)。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”
[img]ProblemImg/P1120.gif[/img]
　　我们假定多多在每个单位时间内，可以做下列四件事情中的一件：
　　1) 从路边跳到最靠近路边(即第一行)的某棵花生植株；
　　2) 从一棵植株跳到前后左右与之相邻的另一棵植株；
　　3) 采摘一棵植株下的花生；
　　4) 从最靠近路边(即第一行)的某棵花生植株跳回路边。
　　现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生?注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。
　　例如在图2所示的花生田里，只有位于(2,5)，(3,7)，(4,2)，(5,4)的植株下长有花生，个数分别为13,7,15,9。沿着图示的路线，多多在21个单位时间内，最多可以采到37个花生。

输入数据
　　输入的第一行包括三个整数， M,N 和 K ，用空格隔开；表示花生田的大小为 M∗N (1≤ M,N≤ 20) ，多多采花生的限定时间为 K (0≤ K≤ 1000) 个单位时间。接下来的 M 行，每行包括 N 个非负整数，也用空格隔开；第 i+1 行的第 j 个整数Pij(0< =Pij< =500)表示花生田里植株  (i,j) 下花生的数目， 0 表示该植株下没有花生。
输出数据
输出包括一行，这一行只包含一个整数，即在限定时间内，多多最多可以采到花生的个数。
样例输入
6 7 21
0 0  0 0 0  0 0
0 0  0 0 13 0 0
0 0  0 0 0  0 7
0 15 0 0 0  0 0
0 0  0 9 0  0 0
0 0  0 0 0  0 0
样例输出
37
```
代码：
```
#include <algorithm>
#include <iostream>
using namespace std;
int n,m,Time,map[21][21],ans = 0;
inline void dfs(int nowtime,int x,int y) {
  //nowtime表示现在的时间
  //x和y表示现在的坐标
  int Maxx,Maxy,Max = -99999;
  for (int i = 1;i <= n;i++)
    for (int j = 1;j <= m;j++)
      if (map[i][j] > Max) {  //找到最大值
        Max = map[i][j];
        Maxx = i;  //记下坐标
        Maxy = j;
      }
  if (!y) y = Maxy;  //如何在路边，跳到Maxy
  if (nowtime < abs(x-Maxx)+abs(y-Maxy)+Maxx+1 || !map[Maxx][Maxy])
  //若现在的时间<采(Maxx,Maxy)的时间+回到路边的时间或是(Maxx,Maxy)上没有花生就结束
    return;
  else {  //采摘
    ans += map[Maxx][Maxy];
    map[Maxx][Maxy] = 0;  //被摘完
    dfs(nowtime-abs(x-Maxx)-abs(y-Maxy)-1,Maxx,Maxy);  //继续
    //nowtime减去需要的时间
    //(x,y)移动到(Maxx,Maxy)
  }
}
int main() {
  ios :: sync_with_stdio(false);
  cin >> n >> m >> Time;
  for (int i = 1;i <= n;i++)
    for (int j = 1;j <= m;j++) cin >> map[i][j];
  dfs(Time,0,0);
  cout << ans;
  return 0;
}
```

### Problem B. 上帝的爱好
```
题目描述
我们知道，词都是按照词牌来填的，上帝为了考验小杉，只给了他四种词牌，但只要压韵就算符合词牌。
小杉已经想好了N个意境优美的句子，每个句子都有一个韵脚。
符合要求的词的句式应当有如下四种" XXYY" ，" XYXY" ，" XYYX" ，" XXXX" ，其中X或Y表示韵脚。
现在小杉想知道，从他想的N个句子之中，最多能按顺序挑选出几首符合条件的词。
并且词的句子间不能交错，比如你选了1 4 6 8做为一首诗，那么7你就不能再选了。

输入数据
每组测试数据的
第一行有一个数 N (N≤ 4000) 。
第二行有N个不超�10^{4}的正整数，第i个整数表示第i个句子的韵脚，整数相同表示韵脚相同。
30 的数据 N≤ 100
输出数据
对每组测试数据输出一行，仅有一个数字，表示小杉最多能挑出几首词来。
样例输入
12
1 2 4 2 3 1 2 2 1 1 2 2
样例输出
2
样例说明
样例最多可以挑出两首词，一种方案如下：
1 2 4 6/9 10 11 12
```
代码：
```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int main()
{
int n;
cin>>n;
int a;
int lia[10001]={0},sum=0,zan=0;
for(int i=1;i<=n;i++)
{
cin>>a;
lia[a]=lia[a]+1;
if(lia[a]==2)
zan=zan+1;
if(zan==2)
{
sum=sum+1,zan=0,memset(lia,0,sizeof(lia));
}
if(lia[a]==4)
{
sum=sum+1,zan=0;
memset(lia,0,sizeof(lia));
}
}
cout<<sum;
return 0;
}
```

### Problem C. 旅行家的预算
```
题目描述
一个旅行家想驾驶汽车以最少的费用从一个城市到另一个城市(假设出发时油箱是空的)。给定两个城市之间的距离d1、汽车油箱的容量c（以升为单位）、每升汽油能行驶的距离d2、出发点每升汽油价格p和沿途油站数n，油站i离出发点的距离d[i]、每升汽油价格p[i]。
计算结果四舍五入至小数点后两位。
如果无法到达目的地，则输出-1。

输入数据
输入共 n+1 行，第一行为 d1,c,d2,p,n ，以下 n 行，每行两个数据，分别表示该油站距出发点的距离 d[i] 和该油站每升汽油的价格 p[i] 。两个数据之间用一个空格隔开。
输出数据
1 < = n < = 100
样例输入
275.6 11.9 27.4 2.8 2
102.0 2.9
220.0 2.2
样例输出
26.95
样例说明
0< =n< =100
```
代码：
```
#include <iostream>
#include <stdio.h>

using namespace std;

int n;
double a,b,c,f;
double sta[102][2]={0};

int nextsta(int now)
{
    int i=now+1,next=now+1;
    while(sta[i][0]-sta[now][0]<=f)
    {
        if(sta[i][1]<sta[now][1])
        {
            next=i;
            break;
        }
        else if(sta[i][1]<sta[next][1])
        {
            next=i;
        }
        i++;
    }
    return next;
}

double buy(double &yx,int &now,int next)//当前油站买油
{
    double ans=0;
    double d=sta[next][0]-sta[now][0];
    if(sta[next][1]<sta[now][1])
    {
        ans=(d/c-yx)*sta[now][1];
        yx=0;
        now=next;
    }
    else
    {
        ans=(b-yx)*sta[now][1];
        yx=b-d/c;
        now=next;
    }
    return ans;
}

int main()
{
    cin>>a>>b>>c>>sta[0][1];
    int i,j;
    double ans=0,yx=0;
    cin>>n;
    f=b*c;
    for(i=1;i<=n;i++)
    {
        cin>>sta[i][0]>>sta[i][1];
        if(sta[i][0]-sta[i-1][0]>f)
        {
            cout<<-1<<endl;
            return 0;
        }
    }
    sta[n+1][0]=a;
    i=0;
    while(i<n+1)
    {
        j=nextsta(i);
        ans+=buy(yx,i,j);
    }
    printf("%.2f\n",ans);
    return 0;
}
```

### Problem D. 旅行
```
题目描述
某趟列车的最大载客容量为V人，沿途共有n个停靠站，其中始发站为第1站，终点站为第n站。
在第1站至第n-1站之间，共有m个团队申请购票搭乘，若规定：
（1）对于某个团队的购票申请，要么全部满足，要么全部拒绝，即不允许只满足部分。（2）每个乘客的搭乘费用为其所乘站数。问：应如何选择这些购票申请，能使该趟列车获得最大的搭乘费用？
其中，每个团队的购票申请格式是以空格分隔的三个整数：a b t，即表示有t个人需要从第a站点乘至第b站点（注：每个团队的所有人员都必须同时在a站上车，且必须同时在后面的b站下车）。

输入数据
输入文件travel.in中有若干行。其中：
第 1 行只有三个整数 n ， m ， v ，分别表示站点数、申请数、列车的最大载客容量。这三个整数之间都以一个空格分隔。
第 2 行至第 m+1 行，每行有三个整数，中间都以一个空格分隔。其中第 k+1 行的三个整数 a ， b ， t 表示第 k 个申请，含义为：有 t 个人需要从第 a 站乘至第 b 站。
其中：1≤n≤10；1≤m≤18
输出数据
输出文件travel.out中只有一行，该行只有一个整数，为该列车能获得的最大搭乘费用。
样例输入
3  3  5
1  2  2
2  3  5
1  3  4
样例输出
8
```
代码：
```
//一道二进制枚举的题目，二进制的每一位表示一个团队选或者不选，用前缀和维护每一站的人数，所有站人数均不超则该方案可行
//总复杂度O(n*2^m)
#include<iostream>
using namespace std;
int a[20],b[20],t[20],sum[20],dp[1<<18];
int main()
{
    int n,m,v,i,j;
    long long mo,ans=0;
    cin>>n>>m>>v;
    for(i=0;i<m;i++)
     cin>>a[i]>>b[i]>>t[i];
     
    for(i=0;i<(1<<m);i++)
     {
        mo=0;
        for(j=0;j<m;j++)
         if(i&(1<<j))
          {
            sum[a[j]]+=t[j];
            sum[b[j]]-=t[j];
            mo+=(b[j]-a[j])*t[j];
          }
         for(j=1;j<=n;j++)
          {
            sum[j]+=sum[j-1];
            if(sum[j]>v)
             break;
          }
        if(j>n)
         ans=max(ans,mo);
        for(j=1;j<=n;j++)
         sum[j]=0;
    }
    
    cout<<ans;
    return 0;
}

```

## 课堂作业（三）
### Problem A. 纪念品分组
```
题目描述
元旦快到了，校学生会让乐乐负责新年晚会的纪念品发放工作。为使得参加晚会的同学所获得 的纪念品价值相对均衡，他要把购来的纪念品根据价格进行分组，但每组最多只能包括两件纪念品， 并且每组纪念品的价格之和不能超过一个给定的整数。为了保证在尽量短的时间内发完所有纪念品，乐乐希望分组的数目最少。

你的任务是写一个程序，找出所有分组方案中分组数最少的一种，输出最少的分组数目。

【限制】

50%的数据满足: 1 < =n < = 15

100%的数据满足: 1 < = n < = 30000， 80 < = W < = 200

输入数据
第 1 行包括一个整数 w ，为每组纪念品价格之和的上眼= 第 2 行为一个整数 n ，表示购来的纪念品的总件数 G 

第 3−n+2 行每行包含一个正整数 Pi (5 ≤ Pi ≤ w3)w 表示所对应纪念品的价格。

输出数据
仅 1 行，包含一个整数，  ep 最少的分组数目合
样例输入
100
9
90
20
20
30
50
60
70
80
90
样例输出
6
```
代码：
```
#include<bits/stdc++.h>
using namespace std;
int a[100001];
int main()
{
    int ans=0,i,j,k=0,l,n,m;
    cin>>m>>n;
    l=n-1;
    for(i=0;i<n;i++)
		cin>>a[i];
    sort(a,a+n); 
    for(i=0;i<n;) {
        if(a[k]+a[l]<=m) k++,l--,i+=2;
        else l--,i++;
        ans++;
    } 
    cout<<ans<<endl;
    return 0;
}

```
### Problem B. Dejected Birthday-盗窃
```
题目描述
基德穿破层层障碍终于来到了" 忧郁的生日" 面前." 忧郁的生日" 如前题所述封存于密码锁中.这个密码锁不是一般的密码锁,这是不一
般的密码锁！这个密码锁上显示着一串数字.旁边还有一串提示:The password is in the number.The number is on screen,you s-
hould delete N numbers as 1,2 or 3...9.The last number should be the smallest of all.The last number is then passwo-
rd（基德:靠,提示居然是E文,无视我400的智商吗?!).为了成功盗取并尽快赶去青子家，基德请你编一个程序解决这个密码锁。

输入数据
输入共 2 行
第一行为一个不超过250位的数字；
第二行则为 N 。
输出数据
输出只有一行，即PASSWORD.
样例输入
178543
4
样例输出
13
样例说明
数据范围
n不超过250位
s不超过n的长度
```

代码：
```
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
char zjy[1000]={0};
int n;
int main()
{
    scanf("%s%d",zjy,&n);
    int lo=strlen(zjy);
    if(lo==n)
    {
        printf("0");
        return 0;
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=0;j<lo-1;j++)
        {
            if(zjy[j]>zjy[j+1])
            {
                for(int k=j;k<lo-1;k++)
                    zjy[k]=zjy[k+1];
                break;
            }
        }
        lo--;
    }
    bool flag=false;
    int e=1;
    for(int i=0;i<lo;i++)
    {
        if(zjy[i]!='0')
            flag=true,e=0;
        if(flag)
            printf("%c",zjy[i]);
    }

    if(e)
        printf("0");
    return 0;
}
```

## 研究生第九次算法作业—贪心算法
### Problem A. 苹果摘陶陶
```
题目描述
话说去年苹果们被陶陶摘下来后都很生气，于是就用最先进的克隆技术把陶陶克隆了好多份> .< 然后把他们挂在树上，准备摘取。
摘取的规则是，一个苹果只能摘一个陶陶，且只能在它所能摘到的高度以下的[b]最高的[/b]陶陶，如果摘不到的话只能灰溜溜的走开了> .< 给出苹果数目及每个苹果可以够到的高度和各个陶陶的高度，求苹果们都摘完后剩下多少个陶陶……

输入数据
第一行为两个数，分别为苹果的数量 n 和陶陶的数量 m （ n,m≤ 2000 ）
以下的 n 行，分别为各个苹果能够到的最大高度。
再接下来的 m 行，分别为各个陶陶的高度。
高度均不高于300。
当然了，摘取的顺序按照输入的“苹果够到的最大高度”的顺序来摘。
输出数据
输出仅有一个数，是剩下的陶陶的数量
样例输入
5 5
9
10
2
3
1
6
7
8
9
10
样例输出
3
```
代码：
```
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[2010];
int b[300];
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    for(int i=1;i<=m;i++){
        int x;
        scanf("%d",&x);
        b[x]++;
    }
    sort(a+1,a+n+1);
    for(int i=1;i<=n;i++){
        for(int j=a[i]-1;j>=1;j--){
            if(b[j]){
                b[j]--;
                m--;
                break;
            }       
        }
    }
    printf("%d",m);
    return 0;
}
```
### Problem B. 我是打饭的
```
题目描述
上午的训练结束了，THU ACM小组集体去吃午餐，他们一行N人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。
THU ACM小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。
现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。
假设THU ACM小组在时刻0到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。
现在给定N个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。

输入数据
第一行一个整数 N ，代表总共有 N 个人。
以下 N 行，每行两个整数  Ai ， Bi 。依次代表第 i 个人的打饭时间和吃饭时间。
输出数据
一个整数 T ，代表所有人吃完饭的最早时刻。
样例输入
5
2 2
7 7
1 3
6 4
8 5
样例输出
17
样例说明
所有输入数据均为不超过200的正整数。
方案如下：
窗口1： 窗口2：
7 7 　　　　 1 3
6 4 8 5
2 2
```
代码：
```
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iomanip>
#include <iostream>
#include <algorithm>
#include <vector>
#include <deque>
#include <limits>
#include <string>
#include <sstream>
using namespace std;

const int oo_min=0xcfcfcfcf,oo_max=0x3f3f3f3f;

struct p_1
{
    int a,b;
}a[200+1];

int n;
int b[200+1];
int f[200+1][200*200+1];

bool cmp_p_1(p_1 x,p_1 y)
{
    return x.b>y.b;
}

int main()
{
    while (~scanf("%d",&n))
    {
        for (int i=1;i<=n;i++)
            scanf("%d%d",&a[i].a,&a[i].b);
        sort(&(a[1]),&(a[n+1]),cmp_p_1);
        memset(b,0,sizeof(b));
        for (int i=1;i<=n;i++)
            b[i]=b[i-1]+a[i].a;
        memset(f,oo_max,sizeof(f));
        f[0][0]=0;
        for (int i=1;i<=n;i++)
            for (int j=0;j<=b[i-1];j++)
            {
                f[i][j]=min(f[i][j],max(f[i-1][j],b[i-1]-j+a[i].a+a[i].b));
                f[i][j+a[i].a]=min(f[i][j+a[i].a],max(f[i-1][j],j+a[i].a+a[i].b));
            }
        int ans=oo_max;
        for (int i=0;i<=b[n];i++)
            ans=min(ans,f[n][i]);
        printf("%d\n",ans);
    }
}
```
### Problem C. 任务调度问题
```
题目描述
一个单位时间任务是恰好需要一个单位时间完成的任务。给定一个单位时间任务的有限集S。关于S 的一个时间表用于描述S 中单位时间任务的执行次序。时间表中第1 个任务从时间0 开始执行直至时间1 结束，第2 个任务从时间1 开始执行至时间2 结束，…，第n个任务从时间n-1 开始执行直至时间n结束。具有截止时间和误时惩罚的单位时间任务时间表问题可描述如下：
(1) n 个单位时间任务的集合S={1,2,…,n}（n≤500）；
(2) 任务i的截止时间d[i],1≤i≤n,1≤d[i]≤n，即要求任务i在时间d[i]之前结束；
(3) 任务i 的误时惩罚1≤w[i]< 1000,1≤i≤n,即任务i 未在时间d[i]之前结束将招致w[i]的惩罚；若按时完成则无惩罚。
任务时间表问题要求确定S 的一个时间表（最优时间表）使得总误时惩罚达到最小。

输入数据
第一行是正整数 n ，表示任务数。接下来的 2 行中，每行有 n 个正整数，分别表示各任务的截止时间和误时惩罚。
输出数据
将计算出的最小总误时惩罚输出
样例输入
7
4 2 4 3 1 4 6
70 60 50 40 30 20 10
样例输出
50
```
代码：
```
#include <stdio.h>
#include <stdlib.h>
typedef struct{
    int time;
    int weight;
}obj,*object;

object objs;
int num = 0;//任务数
int totle = 0;
int order[500];//任务序列

//冒泡排序
void bubble(){
    obj tmp;
    for(int i=0;i<num-1;i++){
        for(int j=0;j<num-i-1;j++)
            if(objs[j].weight>objs[j+1].weight){
                tmp = objs[j];
                objs[j] = objs[j+1];
                objs[j+1] = tmp;
            }
    }
}

void range(){
    for(int i=num-1;i>=0;i--){
        if(order[objs[i].time]==0){
            order[objs[i].time] = 1;
        }else{
            int j = objs[i].time;
            bool change = false;
            for(;j>=1;j--)
                if(order[j]==0){
                    change = true;
                    order[j] = 1;
                    break;
                }
            if(!change)
                totle+=objs[i].weight;
        }
    }
}

int main()
{
    scanf("%d",&num);
    //初始化结构体对象
    objs = (object)malloc(num*sizeof(obj));
    for(int i=0;i<num;i++)
        scanf("%d",&objs[i].time);
    for(int i=0;i<num;i++)
        scanf("%d",&objs[i].weight);
    bubble();
    range();
    printf("%d",totle);
    return 0;
}

```
### Problem D. 魔法师排队
```
题目描述
有n个魔法师在排队买魔法面包，每个魔法师都有自己的魔力值，用一个正整数表示。 魔法师都不喜欢排队，如果任意时刻某个魔法师发现前面的魔法师的魔力值比自己小，那么这个魔法师就会用法术把前面的人传送到异空间。 请输出有多少个魔法师会被传送到异空间。

输入数据
第一行为一个正整数n，代表魔法师的人数。 接下来一行位n个正整数，第i个正整数ai代表队伍中第i个魔法师的魔力值。（第1个魔法师在队头，第n个魔法师在队尾） 1<=n<=1000000 1<=ai<=100000000

输出数据
被传送到异空间的魔法师个数

样例输入
5
4 5 1 3 2
样例输出
2
```
代码：
```
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <vector>

using namespace std;

const int maxN = int(1e6 + 10);
int n, a[maxN], max_num, cont;
int i;

int main() {
    cin >> n;
    for (i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
    }
    max_num = a[n];
    for (i = n - 1; i > 0; i--) {
        if (a[i] < max_num) {
            cont++;
        } else {
            max_num = a[i];
        }
    }
    cout << cont << endl;
    return 0;
}
```